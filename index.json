[{"content":"语言模型 计算文本序列概率的模型叫做语言模型（LMs）。下面简单介绍如何使用 n-gram 模型来估计给定前一个单词的n-gram的最后一个单词的概率，并将概率分配给整个序列。把 n-gram 一些重点内容记录一下：\n形式 $P(the|its \\ water \\ is \\ so \\ transparent \\ that)$\n简单直观的计算方式使用统计计数 $P(the|its \\ water \\ is \\ so \\ transparent \\ that) = {C(its \\ water \\ is \\ so \\ transparent \\ that \\ the) \\over C(its \\ water \\ is \\ so \\ transparent \\ that)}$\n这种方式在有新的句子加入时不利于维护，所以可以使用链式法则求出概率：$\\begin{align} P(x^{(1)},\\cdots,x^{(T)}) \u0026amp;= P(x^{(1)})\\times P(x^{(2)}|x^{(1)})\\times \\cdots \\times P(x^{(T)}|,\\cdots,x^{(1)}) \\ \u0026amp;= \\prod^T_{t=1} P(x^{(t)}|x^{(t-1)},\\cdots,x^{(1)})\\end{align}$\n但是根据前面整个句子的概率去计算下一个词，计算量太大，并且也不是完全依赖前面所有的词。可以根据前几个词来计算概率，所以有了 n-gram 模型。\n为了计算语言模型，我们需要计算词的概率，以及一个词在给定前几个词的情况下的条件概率，即语言模型参数。设训练数据集为一个大型文本语料库，如维基百科的所有条目。词的概率可以通过该词在训练数据集中的相对词频来计算。例如，$P(w_1)$可以计算为 $w_1$ 在训练数据集中的词频（词出现的次数）与训练数据集的总词数之比。因此，根据条件概率定义，一个词在给定前几个词的情况下的条件概率也可以通过训练数据集中的相对词频计算。例如，$P(w_2∣w_1)$可以计算为$w_1,w_2$两词相邻的频率与 $w_1$ 词频的比值，因为该比值即 $P(w_1,w_2)$ 与 $ P( w_1) $ 之比；而 $P(w_3|w_1,w_2)$ 同理可以计算为$w_1、w_2$ 和 $w_3$ 三词相邻的频率与 $w_1$ 和 $w_2$ 两词相邻的频率的比值。以此类推。\nN-gram 语言模型 N-gram 是一个由 n 个连续单词组成的块，它的思想是一个单词出现的概率与它前 n-1 个出现的词有关。也就是每个词依赖于前 n-1 个词。下面是一些常见的术语以及示例，可以帮助你更好的理解 N-gram 语言模型：\n Unigrams：一元文法，由一个单词组成的 token，例如： “the”, “students”, “opened”, ”their”。 Bigrams：二元文法，也叫一元马尔科夫链。由连续两个单词组成的 token，例如：“the students”, “students opened”, “opened their”。 Trigrams：三元文法，由连续三个单词组成的 token，例如：“the students opened”, “students opened their”。 4-grams：四元文法，由连续四个单词组成的 token，例如：“the students opened their”。  如何估计这些 n-gram 概率？估计概率的一种直观方法叫做极大似然估计（MLE）。可以通过从正态语料库中获取计数，并将计数归一化，使其位于 0 到 1 之间，从而得到 n-gram 模型参数的最大似然估计。\n例如，要计算一个给定前一个单词为 x ，y 的 bigram 概率，将计算 bigram C(x y)的计数，并通过共享相同第一个单词 x的所有 bigram 的总和进行标准化。\n$P(X_n|X_{n-1}) = {C(X_{n-1} X_n) \\over \\sum_X C(X_{n-1}X)}$\n其中分子为 bigram C(x y) 在语料库中的计数，分母为前一个词为 x，后一个为任意词的 bigram 计数的总和。为了简单可以写成下面的形式：\n$P(X_n|X_{n-1}) = {C(X_{n-1} X_n) \\over C(X_{n-1})}$\n这样就通过极大似然估计求得了概率值。但是有个问题是，在其他语料库中出现次数很多的句子可能在当前语料库中没有，所以很难进行泛化。下面是 n-gram 模型的稀疏性问题：\n  如果要求的词没有在文本中出现，也就是分子的概率为 0。解决办法是添加一个很小的值给对应的词，这种方法叫做平滑，例如拉普拉斯平滑。这使得词表中的每个单词都至少有很小的概率。\n  如果前 n-1 个词没有出现在文本中，也就是分母的概率无法计算。解决办法如使用 “water is so transparent that“ 替代，这种方法叫做后退。保证作为条件的分母概率值存在。（还有其他平滑技术）\n  需要注意的是，概率是一个大于 0 小于 1 的数，随着相乘会变得很小。所以通常使用 log 的形式：\n$p_1 \\times p_2 \\times p_3 \\times p_4 = exp(log\\ p_1 + log\\ p_2 + log \\ p_3 + log\\ p_4)$\n  还有的是提高 n 的值会使稀疏性变得更糟糕，还会增加存储量，所以 n-gram 一般不会超过 5。\n  当n\u0026gt;2时，比如 tigram，可能需要在头部添加两个start-token，后续看看效果如何。\n  平滑技术 上面提到过，一些 OOV 词汇，模型会分配 0 概率，这样是错误的。因而，必须分配给所有可能出现的字符串一个非零的概率值来避免这种错误的发生。平滑（smoothing）技术就是用来解决这类零概率问题的。提高低概率（如零概率），降低高概率，尽量使概率分布趋于均匀。\n拉普拉斯平滑 Laplace Smoothing，做平滑的最简单的方法是在我们将它们归一化为概率之前，在所有的计数上加1。拉普拉斯平滑在现代 n-gram 模型中并没有得到很好的应用，但它很好地引入了我们在其他平滑算法中看到的许多概念，给出了一个有用的基线，也是文本分类等其他任务的实用平滑算法。下面在 1-gram 上看看拉普拉斯平滑：\n$P_{Laplace}(w_i) = {c_i + 1 \\over N+V}$\n加法平滑 拉普拉斯平滑也算是加法平滑的一种，加法平滑的一般形式：\n$P_{Add-k}(w_n|w_{n-1}) = {C(w_{n-1}w_n)+k \\over C(w_{n-1}+kV)}$\n尽管 add-k 在某些任务(包括文本分类)中很有用，但它在语言建模中仍然不能很好地工作，生成的计数方差很差。\nKatz 平滑 Kneser-Ney 平滑 Backoff and Interpolation 评估方法 困惑度 在 NLP 中，通常使用困惑度（Perplexity，PPL）作为衡量语言模型好坏的内部指标，此外还有外部指标需要人工评价\n$\\begin{align} P(W) \u0026amp;= P(w_1 w_2 \\cdots w_N)^{-{1\\over N}} \\ \u0026amp;= \\sqrt[N]{1\\over P(w_1 w_2 \\cdots w_N)} \\ \u0026amp;= \\sqrt[N]{\\prod^N_{i=1}{1\\over P(w_i|w_1\\cdots w_{i-1})}} \\end{align}$\n对于 bigram 模型的困惑度：\n$PP(W) = \\sqrt[N]{\\prod^N_{i=1} {1\\over P(w_i|w_{i-1})}}$\n困惑度越低，说明生成的语言越接近真实语言，常用于机器翻译和文本生成等 NLP 任务中。困惑度等价于交叉熵损失函数：\n$\\begin{align} \u0026amp;= \\prod^T_{t=1}({1\\over \\hat{y}^{(t)}{x{t+1}}})^{1\\over T} \\ \u0026amp;=exp({1\\over T \\sum^T_{t=1}}-log\\hat{y}^{(t)}{x{t+1}}) \\ \u0026amp;= exp(J(\\theta)) \\end{align}$\nReferences  N-gram Language Models 《统计自然语言处理》- 宗成庆  ","permalink":"https://hiyoungai.com/posts/ngram%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/","summary":"语言模型 计算文本序列概率的模型叫做语言模型（LMs）。下面简单介绍如何使用 n-gram 模型来估计给定前一个单词的n-gram的最后一个单词的概率，并将","title":"Ngram语言模型"},{"content":"1.1 编写一个简单的 C++ 程序 1.1.1 Example int main() { return 0; }  每个 C++ 程序必须包含一个或者多个函数，其中一个必须命名为 main 函数。 一个函数必须包含四部分：返回类型、函数名、形参列表和函数体。  1.1.2 编译、运行程序   程序源码存在一个或者多个文件中，通常称为源文件，常见后缀 .cc、.cxx、.cpp、.cp 以及 .c。\n  常见编译器：g++、gcc、cl\n  编译流程\n源代码 test.c 预处理 test.i 编译 test.s 汇编 test.o 链接 test.ext/test.out   编译命令\ng++ -std=c++11 -Wall -o prog01 prog01.cpp   运行可执行文件\n./prog01   查看运行状态\necho %ERRORLEVEL% # windows echo $? # UNIX   编译多个文件\ng++ -std=c++11 -Wall prog01.cpp Sales_item.cc -o prog01   g++ 常用命令\n-std=c++11 # 指定c++版本 -Wall # 输出所有编译警告信息 -E # 预处理 -S # 编译 -c # 汇编 -o # 指定可执行文件并进行链接阶段 -g # 输出调试信息 -fPIC # 链接动态库 -Dmacro=XXX # 定义宏 -llibrarytest # 链接 librarytest 库 -L # 指定库文件路径 -I #    1.2 初始输入输出 1.2.1 标准输入输出对象  标准输入输出库：iostream，包括 istream 和 ostream。 一个流就是一个字符序列，是从 IO 设备读出或者写入 IO 设备的。随着时间推移，字符是顺序生成或者消耗。 标准库定义了 4 个 IO 对象：cin 标准输入、cout 标准输出、cerr 标准错误、clog 标准日志信息。  1.2.2 一个使用 IO 库的程序 #include \u0026lt;iostream\u0026gt;int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Enter two numbers:\u0026#34; \u0026lt;\u0026lt; std::endl; int vl = 0, v2 = 0; std::cin \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2; std::cout \u0026lt;\u0026lt; \u0026#34;The sum of \u0026#34; \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; \u0026#34; and\u0026#34; \u0026lt;\u0026lt; v2 \u0026lt;\u0026lt; \u0026#34; is\u0026#34; \u0026lt;\u0026lt; v1 + v2 \u0026lt;\u0026lt; std::endl; return 0; }  标准库的头文件使用 \u0026lt;\u0026gt;，非标准库的头文件使用 \u0026quot;\u0026quot; \u0026lt;\u0026lt; 称为输出运算符，接收两个运算对象，左侧的运算对象必须是 ostream 对象，右侧的运算对象是要打印的值。与之对称的是输入运算符 \u0026gt;\u0026gt; 。 字符串字面常量，是被两个双引号包着的字符序列。 endl 称为操纵符，效果是结束当前行，并把设备关联的缓冲区的内入刷新到设备中，保证执行到当前语句时，程序所产生的输出真正的写入到输出流中，而不是停留在缓存区。 std 是标准库的命名空间，命名空间的作用是防止命名冲突。 :: 是作用域运算符，作用是访问标准库中的名字。  1.3 注释简介   注释的作用是帮助人类读者理解程序。\n  注释分为单行注释 // 和界定符注释 /**/（也叫多行注释）。\n  注释界定符 /**/ 不能嵌套。\n  双引号内的注释会被忽略。\n#define SALESITEM_H /* * 多行注释格式 * 每一行加一个* */   1.4 控制流 1.4.1 while 语句 #include \u0026lt;iostream\u0026gt;int main() { int sum = 0, val = 1; // 只要 val 的值小于等于 10， while 循环就会继续执行  while (val \u0026lt;= 10) { sum += val; ++val; } std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; }  while 语句反复执行一段代码，直到条件为假为止。 复合赋值运算符 a += b，表示 a = a+b 前缀递增运算符 ++a，表示 a = a+1  1.4.2 for 语句 #include \u0026lt;iostream\u0026gt;int main() { int sum = 0; // 从 1 加到 10  for (int val = 1; val \u0026lt;= 10; ++val) { sum += val; // 等价于 sum = sum + val  } std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 循环头由三部分组成：\n 一个初始化语句（init-statement） 一个循环条件（condition） 一个表达式（expression）  1.4.3 读取数量不定的输入数据 #include \u0026lt;iostream\u0026gt;int main() { int sum = 0, value = 0; // 读取数据直到遇到文件尾，计算所有读入的值的和  while (std::cin\u0026gt;\u0026gt;value) { sum += value; } std::cout \u0026lt;\u0026lt; \u0026#34;Sum is: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 1.4.4 if 语句 #include \u0026lt;iostream\u0026gt;int main() { // currVal 是要统计的数  int currVal = 0, val = 0; // 读取第一个数  if (std::cin\u0026gt;\u0026gt;currVal) { int cnt = 1; while (std::cin\u0026gt;\u0026gt;val) { if (val == currVal) { ++cnt; } else { std::cout \u0026lt;\u0026lt; currVal \u0026lt;\u0026lt; \u0026#34; occurs\u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; std::endl; currVal = val; cnt = 1; } } std::cout \u0026lt;\u0026lt; currVal \u0026lt;\u0026lt; \u0026#34; occurs\u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; }  if 语句支持条件执行，条件中可以出现 == 条件运算符页可以出现 = 赋值运算符，注意区分。   编译器可以检查形式上的错误，包括：语法错误、类型错误、声明错误。\n 1.5 类简介   使用类来定义数据结构。通常自己定义的类要放在头文件中，头文件的后缀通常时 .h 或者 .hpp、.hxx。\n  文件重定向操作\naddItems \u0026lt; infile \u0026gt; outfile addItems 是可执行程序 \u0026lt; infile 表示从infile文件中获取数据，作为addItems程序的参数 \u0026gt; outfile 表示addItems的输出输入到 outfile 中   成员函数是类的一部分的函数，也叫做方法。调用成员函数的方法为 类对象.函数名。\n  1.6 书店程序 #include \u0026lt;iostream\u0026gt;#include \u0026#34;Sales_item.h\u0026#34; int main() { Sales_item total; if (std::cin\u0026gt;\u0026gt;total) { Sales_item trans; while (std::cin\u0026gt;\u0026gt;trans) { if (total.isbn() == trans.isbn()) { total += trans; } else { std::cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; std::endl; total = trans; } } std::cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; std::endl; } else { std::cerr \u0026lt;\u0026lt; \u0026#34;No data ? \u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } return 0; } ","permalink":"https://hiyoungai.com/posts/c++-primer-%E4%B8%AD%E6%96%87%E7%89%88%E7%AC%AC-5-%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC01%E7%AB%A0-%E5%BC%80%E5%A7%8B/","summary":"1.1 编写一个简单的 C++ 程序 1.1.1 Example int main() { return 0; } 每个 C++ 程序必须包含一个或者多个函数，其中一个必须命名为 main 函数。 一个函数必须包含四部分：返回类型、函数名","title":"《C++ Primer 中文版（第 5 版）》学习笔记-第01章 开始"},{"content":"前言 学习决策树时会接触到一些信息熵,条件熵和信息增益的知识,此外还有互信息,相对熵,交叉熵和互信息,KL散度等等乱七八糟的知识和名字,我本人已经记得大脑混乱了,还没有全部记住,所以在这里记录一下.\n信息熵 信息的度量，信息的不确定程度，是乱七八糟熵的基础。吴军大大的数学之美中用了猜球队冠军的方式引出了信息熵的概念。我觉得这种方法印象很深刻，所以在这里提出一下。如果有32支球队，使用二分查找法去猜哪支球队是冠军，如：冠军在1-16号球队内。这样一共需要猜5次就可以找到结果，也就是$log32=5$。但是某些球队的获胜率大一些，所以它的准确信息量的表示应该如下:\n$H(X) = - \\sum_{x\\in X}P(x)logP(x)$\n香农称它为信息熵，表示信息的不确定程度。不确定性越大，信息熵也就越大。图1中的$P(x)$表示随机变量$x$的概率，信息熵$H(X)$的取值范围：$0\u0026lt;=H(X)\u0026lt;=logn$，其中$n$是随机变量$X$取值的种类数。\n条件熵 有两个随机变量$X$和$Y$，在已知$Y$的情况下，求$X$的信息熵称之为条件熵：\n$H(X|Y) = -\\sum_{x\\in X,y\\in Y}P(x,y)logP(x|y)$\n其中$P(x|y)$是已知$y$求$x$的条件概率，$P(x,y)$是联合概率。\n联合熵 联合熵可以表示为两个事件$X$、$Y$的熵的并集：\n$H(X,Y) = -\\sum_{i=1}^n \\sum_{j=1}^n P(x_i,y_i)logP(x_i,y_i)$ $= \\sum_{i=1}^n \\sum_{j=1}^n P(x_i,y_i)log{1\\over P(x_i,y_i\t)}$\n它的取值范围是：$max(H(x),H(y)) \u0026lt;= H(x,y) \u0026lt;= H(x)+H(y)$\n信息增益 表示在确定某条件Y后，随机变量$X$的信息不确定性减少的程度，也称为互信息($Mutual Information$).\n$I(X;Y) = H(X) - H(X|Y)$\n它的取值是$0$到$min(H(X),H(Y))$之间的数值，取值为$0$时表示两个事件$X$和$Y$完全不相关。在决策树算法中$ID3$算法就是使用信息增益来划分特征的。在某个特征条件下，求数据的信息增益，信息增益大的特征说明对数据划分帮助很大。优先选择该特征进行决策树的划分，这就是$ID3$算法。\n信息增益比（率） 信息增益比是信息增益的进化版，用于解决信息增益对属性选择取值较多的问题。信息增益率为信息增益与该特征的信息熵之比。在决策树中算法中，$C4.5$算法就是使用信息增益比来划分特征。公式如下：\n$g_R(D,A) = {g(D,A)\\over H(D)} $\n信息熵，条件熵和互信息的关系：\n基尼系数（Gini） 在决策树的$CART$(分类回归树)中有两类树，一是回归树，划分特征使用的是平方误差最小化的方法。二是分类树，采用的就是$Gini$系数最小化进行划分数据集。\n$Gini(P) = \\sum_{k=1}^K p_k(1-p_k) = 1 - \\sum_{k=1}^K p_k^2$\n其中$k$为$label$的种类数。基尼指数越大，信息的不确定性越大，这与信息熵相同。（$CART$树是如何使用$Gini$指数的这里就不详细介绍了，以后会在决策树中详细介绍的。）\n相对熵（KL散度） 用来描述两个概率分布$P$、$Q$之间的差异，数学之美中介绍是用来衡量两个取值为正数函数的相似性：\n$KL（P||Q）= \\sum_{i=1}^n P(x_i)log{P(x_i)\\over Q(x_i)}$\n如果两个函数(分布)完全相同，那么它们的相对熵为0。同理如果相对熵越大，说明它们之间的差异越大，反之相对熵越小，说明它们之间的差异越小。需要注意的是相对熵不是对称的，也就是：\n$KL(P||Q)\\neq KL(Q||P)$\n但是这样计算很不方便，所以香农和杰森（不是郭达斯坦森）提出了一个新的对称的相对熵公式：\n$JS(P||Q) = {1\\over 2}[KL(P||Q) + KL(Q||P)]$\n上面的相对熵公式可以用于计算两个文本的相似度。吴军大大在《数学之美》中介绍，$Google$的问答系统就是用这个公式计算答案相似性的（现在还是不是就不清楚了）。\n交叉熵（Cross-Entropy） 我们知道通常深度学习模型最后一般都会使用交叉熵作为模型的损失函数。那是为什么呢？首先我们先将相对熵$KL$公式进行变换（$log$中除法可以拆分为两个$log$相减）:\n$D_{KL}(P||Q) = \\sum_{i=1}^n P(x_i)log(P(x_i)) - \\sum_{i=1}^n P(x_i)log(Q(x_i))$ $= -H(P(x)) + [-\\sum_{i=1}^n P(x_i)log(Q(x_i))]$\n其中前一部分的$-H(P(x))$是$P$的信息熵，后一部分就是我们所说的交叉熵。\n$H(P,Q) = -\\sum_{i=1}^n P(x_i)log(Q(x_i))$\n损失函数是计算模型预测值和数据真实值之间的相关性，所以可以使用相对熵（$KL$散度）计算。根据上述公式可以看出：$-H(P(x))$是不变的，所以我们可以通过计算后一部分的交叉熵来求得$Loss$。所以通常会使用交叉熵来作为$Loss$函数。同理交叉熵越小，预测值和真实值之间相似度越高，模型越好。\n LR的损失函数就是交叉熵。\n 困惑度（Perplexity，PPL） 在$NLP$中，通常使用困惑度作为衡量语言模型好坏的指标。\n$PP(S) = P(w_1w_2\\dots w_n)^{-{1\\over N}}$ $= \\sqrt[N]{1\\over{P(w_1w_2\\dots w_n)}}$ $= \\sqrt[N]{\\prod_{i=1}^n {1\\over P(w_i|w_1w_2\\dots w_{i-1})}}$\n其中$S$为句子，$N$是句子中单词的个数，$P(w_i)$代表第$i$个单词的概率。所以$PPL$越小$P(w_i)$的概率越高，则这句话$S$属于自然语言的概率也就越高。\n","permalink":"https://hiyoungai.com/posts/%E4%BF%A1%E6%81%AF%E7%86%B5%E6%80%BB%E7%BB%93/","summary":"前言 学习决策树时会接触到一些信息熵,条件熵和信息增益的知识,此外还有互信息,相对熵,交叉熵和互信息,KL散度等等乱七八糟的知识和名字,我本人","title":"信息熵总结"},{"content":"标题 Markdown支持6种级别的标题，对应html标签 h1 ~ h6，严格的Markdown语法＃和文本之间要有一个空格。\n# h1　这是一级标题 ## h2　这是二级标题 ### h3　这是三级标题 #### h4　这是四级标题 ##### h5　这是五级标题 ###### h6　这是六级标题 效果如下（实际演示会造成菜单混乱，所以此处使用截图）：\n除此之外，Markdown还支持另外一种形式的标题展示形式，使用下划线进行文本大小的控制。但是这种形式仅有两种表现形式：即一级标题和二级标题。\n这是一级标题 ========== 这是二级标题 ---------- 效果如下：\n 分割线 使用三个或者三个以上的-或者*都可以。\n--- ---- *** ***** 效果如下：\n    可以看出效果都是一样的。\n 字体   粗体\n要加粗的文字左右分别用两个*号或下划线_包起来。\n  斜体\n要加斜的文字左右分别用一个*号或下划线_包起来。\n  斜粗体\n要加粗加斜的文字左右分别用三个*号或下划线_包起来。\n  删除线\n要加删除线的文字左右分别用两个波浪线~~包起来。\n  下划线\n要加下划线可以通过 HTML 的\u0026lt;u\u0026gt;标签来实现。\n  高亮\n文字高亮功能能使行内部分文字高亮，使用一对反引号。\n  **这是加粗的文字** __这是加粗的文字__ *这是倾斜的文字* _这是倾斜的文字_ ***这是斜体加粗的文字*** ___这是斜体加粗的文字___ ~~这是加删除线的文字~~ \u0026lt;u\u0026gt;这是加下划线的文字\u0026lt;/u\u0026gt; 这是要`高亮`的文字 效果如下：\n这是加粗的文字 这是加粗的文字 这是倾斜的文字 这是倾斜的文字 这是斜体加粗的文字 这是斜体加粗的文字 这是加删除线的文字 这是加下划线的文字这是要高亮的文字\n 引用 在引用的文字前加\u0026gt;即可，同样严格语法需要中间加一个空格。引用也可以嵌套，如加两个\u0026gt;\u0026gt;三个\u0026gt;\u0026gt;\u0026gt;n个\u0026hellip;\n\u0026gt;最外层嵌套 \u0026gt;\u0026gt;第一层嵌套 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;最内层嵌套 效果如下：\n 最外层嵌套\n 第一层嵌套\n          最内层嵌套\n           列表 Markdown 支持有序列表和无序列表。无序列表使用星号*、加号+或是减号-作为列表标记：\n* 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 效果如下：\n 第一项 第二项 第三项   第一项 第二项 第三项   第一项 第二项 第三项  有序列表使用数字并加上 . 号来表示，如：\n1. 第一项 2. 第二项 3. 第三项 效果如下：\n 第一项 第二项 第三项  列表可以嵌套使用，只需在子列表中的选项添加四个空格即可：\n1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 效果如下：\n 第一项：  第一项嵌套的第一个元素 第一项嵌套的第二个元素   第二项：  第二项嵌套的第一个元素 第二项嵌套的第二个元素     代码 如果是段落上的一个函数或片段的代码可以用反引号把它包起来，例如：\n`print()`函数 效果如下：\nprint()函数\n代码块需要使用４个空格或者一个制表符（Tab键）：\nfun (x: Int, y: Int): Int { return x + y } ​\t效果如下\nfun (x: Int, y: Int): Int { return x + y } 或者使用'\u0026lsquo;\u0026lsquo;code'\u0026lsquo;\u0026lsquo;把代码包裹起来，也可以指定代码语言，这样可以进行代码高亮：\n```javascript $(document).ready(function () { alert('RUNOOB'); }); ​``` 效果如下：\n$(document).ready(function () { alert(\u0026#39;RUNOOB\u0026#39;); });  链接 基本链接的使用方法 [链接名称](链接地址 \u0026quot;描述\u0026quot;)　其中描述为鼠标放到url的显示文字，可加可不加。 或者 \u0026lt;链接地址\u0026gt; 这是一个链接 [hiyoung blog](https://hiyoungai.com　\u0026#34;我的博客\u0026#34;) 效果如下：\n这是一个链接 hiyoung blog\n直接使用链接地址：\n(https://hiyoungai.com) 效果如下：\nhttps://hiyoungai.com\n高级链接的使用方法 链接使用变量代替，文档末尾定义变量且带有链接地址。 这个链接使用１作为链接变量[Google][1] 这个链接使用url作为链接变量[baidu][url] [1]:https://www.google.com [url]:https://www.baidu.com 效果如下：\n这个链接使用１作为链接变量Google 这个链接使用url作为链接变量baidu\n锚点链接 每一个标题都是一个锚点，和HTML的锚点#类似：\n[回到顶部](#Markdown基本语法) 效果如下：\n回到顶部\n 图片 基本语法：\n![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026quot;可选标题title\u0026quot;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 也可以使用高级链接的方式，此处不再演示。 例子： ![Write](https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/img_markdown.jpeg \u0026quot;写作\u0026quot;) 效果如下：\n 表格 Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n基本语法 | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 效果如下：\n   表头 表头     单元格 单元格   单元格 单元格    对齐方式 我们可以设置表格的对齐方式：\n -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。  效果如下：\n| 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 效果如下：\n   左对齐 右对齐 居中对齐     单元格 单元格 单元格   单元格 单元格 单元格    而且表格中也可以混用其他语法：如粗体斜体，插入图片等。\n 高级技巧 支持html元素 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：\u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt;等 ，如：\n使用 \u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Alt\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Del\u0026lt;/kbd\u0026gt; 重启电脑 效果如下：\n使用 Ctrl+Alt+Del重启电脑\n转义字符 Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdow使用反斜杠转义特殊字符：\n**文本加粗** \\*\\* 正常显示星号 \\*\\* 效果如下：\n文本加粗 ** 正常显示星号 **\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号 数学公式 当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n$$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\\\ \\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\\\ \\end{vmatrix} $$ 效果如下： $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} \u0026amp; \\mathbf{j} \u0026amp; \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} \u0026amp; \\frac{\\partial Y}{\\partial u} \u0026amp; 0 \\ \\frac{\\partial X}{\\partial v} \u0026amp; \\frac{\\partial Y}{\\partial v} \u0026amp; 0 \\ \\end{vmatrix} $$\n流程图 流程图需要平台支持，而我使用的hexo，需要安装如下三个插件：\nnpm install --save hexo-filter-flowchart npm install --save hexo-filter-mermaid-diagrams npm install --save hexo-filter-sequence 同时，对于Matery主题的博客还需要配置一下_config.xml和修改footer.ejs。\n在主题的_config.yml中添加如下代码：\n# Mermaid tag mermaid: enable: true # Available themes: default | dark | forest | neutral theme: forest cdn: https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js #cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js 在footer.ejs的结尾处添加：\n\u0026lt;div class=\u0026quot;progress-bar\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;% if (theme.mermaid.enable) { %\u0026gt; \u0026lt;script src='\u0026lt;%= theme.mermaid.cdn %\u0026gt;'\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; if (window.mermaid) { mermaid.initialize({theme: 'forest'}); } \u0026lt;/script\u0026gt; \u0026lt;% } %\u0026gt; 如果不使用mermaid的话那么不需要上述配置。\n横向流程图 ```mermaid graph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] ​``` graph LR A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[横向流程图] 纵向流程图 ```mermaid graph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] ​``` graph TD A[方形] --\u0026gt; B(圆角) B --\u0026gt; C{条件a} C --\u0026gt; |a=1| D[结果1] C --\u0026gt; |a=2| E[结果2] F[竖向流程图] 标准流程图 ```flow st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;io-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op ​``` st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;io-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op 标准流程图（横向） ```flow st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op ​``` st=\u0026gt;start: 开始框 op=\u0026gt;operation: 处理框 cond=\u0026gt;condition: 判断框(是或否?) sub1=\u0026gt;subroutine: 子流程 io=\u0026gt;inputoutput: 输入输出框 e=\u0026gt;end: 结束框 st(right)-\u0026gt;op(right)-\u0026gt;cond cond(yes)-\u0026gt;io(bottom)-\u0026gt;e cond(no)-\u0026gt;sub1(right)-\u0026gt;op UML时序图 ```sequence 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象A-\u0026gt;对象B: 你真的好吗？ ​``` 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象A-\u0026gt;对象B: 你真的好吗？ UML时序图（复杂样例） ```sequence Title: 标题：复杂使用 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象B-\u0026gt;小三: 你好吗 小三--\u0026gt;\u0026gt;对象A: 对象B找我了 对象A-\u0026gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 ​``` Title: 标题：复杂使用 对象A-\u0026gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--\u0026gt;对象A: 我很好(响应) 对象B-\u0026gt;小三: 你好吗 小三--\u0026gt;\u0026gt;对象A: 对象B找我了 对象A-\u0026gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 UML标准时序图 ```mermaid %% 时序图例子,-\u0026gt; 直线，--\u0026gt;虚线，-\u0026gt;\u0026gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-\u0026gt;王五: 王五你好吗？ loop 健康检查 王五-\u0026gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 \u0026lt;br/\u0026gt;看医生... 李四--\u0026gt;\u0026gt;张三: 很好! 王五-\u0026gt;李四: 你怎么样? 李四--\u0026gt;王五: 很好! ​``` %% 时序图例子,-\u0026gt; 直线，--\u0026gt;虚线，-\u0026gt;\u0026gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-\u0026gt;王五: 王五你好吗？ loop 健康检查 王五-\u0026gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 \u0026lt;br/\u0026gt;看医生... 李四--\u0026gt;\u0026gt;张三: 很好! 王五-\u0026gt;李四: 你怎么样? 李四--\u0026gt;王五: 很好! 甘特图 ```mermaid %% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h ​``` %% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h Emoj表情 Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包着的字符）可以显示出不同的表情（本网站没有添加该插件，需要支持Github的markdwon才可以正常显示）：\n:bluesh: 效果如下：\n😀\n具体每一个表情的符号码，可以查询Github的官方网页http://www.emoji-cheat-sheet.com。\n插入视频 \u0026lt;video id=\u0026quot;video\u0026quot; controls=\u0026quot;\u0026quot; preload=\u0026quot;none\u0026quot; poster=\u0026quot;缩略图\u0026quot;\u0026gt; \u0026lt;source id=\u0026quot;视频url\u0026quot; type=\u0026quot;video/mp4\u0026quot;\u0026gt; \u0026lt;/video\u0026gt; 例子： \u0026lt;video id=\u0026quot;video\u0026quot; controls=\u0026quot;\u0026quot; preload=\u0026quot;none\u0026quot; poster=\u0026quot;\u0026quot;\u0026gt; \u0026lt;source id=\u0026quot;mp4\u0026quot; src=\u0026quot;https://www.typora.io/img/beta.mp4\u0026quot;\u0026gt; \u0026lt;/video\u0026gt; 效果可在Typora看到。\n插入Github Star  \u0026lt;iframe style=\u0026quot;margin-left: 2px; margin-bottom:-5px;\u0026quot; frameborder=\u0026quot;0\u0026quot; scrolling=\u0026quot;0\u0026quot; width=\u0026quot;100px\u0026quot; height=\u0026quot;20px\u0026quot; src=\u0026quot;https://ghbtns.com/github-btn.html?user=hiyoung123\u0026amp;repo=hiyoung123.github.io\u0026amp;type=star\u0026amp;count=true\u0026quot; \u0026gt; \u0026lt;/iframe\u0026gt; 效果如下：\n 工具介绍 Typora 特点：简洁，快速，可以实现所见即所得。看下面这个视频你就会知道他的Simple, yet Powerful\nTypora官方下载\nAtom 特点：插件丰富（毕竟是Github推出的），并且可以用作其他语言的编辑器。其实也可以做到一边编辑一边看结果，只不过是需要多开一个窗口，😄！\nAtom下载地址\n总结 作者也是刚开始接触这两个软件，所以不是特别熟悉，等使用一段时间，对比之后再来详细的写一下。 流程图插件配置参考博客：https://blog.csdn.net/Olivia_Vang/article/details/92987859\n","permalink":"https://hiyoungai.com/posts/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","summary":"标题 Markdown支持6种级别的标题，对应html标签 h1 ~ h6，严格的Markdown语法＃和文本之间要有一个空格。 # h1 这是一级标题 ## h2 这","title":"Markdown基本语法"},{"content":" 使用Hexo+Github搭建一个免费的个人博客，本文略长，大佬请自行选择阅读。\n 前言 一边上班一边搭建博客，忙了大概有一周左右的时间，终于把博客都调好了。我使用的是Hexo框架，主题是闪烁之狐之狐的hexo-theme-matery，本文介绍的也是该主题的配置，大家如果喜欢可以去下载使用。\n本文除了介绍了matery主题的一些基础配置之外，也介绍了一些我个人和在其他大佬处看到的功能定制。只要你懂得操作软件，懂得键盘打字，那么就可以通过本教程搭建一个完全免费的个人博客。如果你是技术大佬，那么更可以通过修改源码去定制更好的功能。本文也记录了一些我搭建过程中遇到的坑，希望可以帮你在搭建过程中少走一些弯路，同时如果你也遇到一些本文没有记载的bug，也请你给我留言，让我们一起学习解决，多谢。\n第一部分：准备 1.Hexo介绍 Hexo是一款快速、简洁且高效的基于Node.js的静态博客框架，四大特性：\n 超快速度：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持Markdown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署：只需一条指令即可部署到 GitHub Pages, Heroku或其他平台。 插件和可扩展性：强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less/Sass）轻易集成。  这使得很多非编程人员可以很轻松，很自由的定制博客。废话不多说，开始进入搭建环境把。\n2.安装Node环境 Linux 直接命令行输入：\nsudo apt-get install nodejs sudo apt-get install npm 或者到官网下载：\n下载完成后解压到指定文件夹，然后配置环境变量（目的是为了在终端可以任意位置使用它）：\n首先打开~/.bashrc文件\nvim ~/.bashrc 在文件的最下端填写如下代码\nexport PATH=${PATH}:$HOME/node-v12.13.0-linux-x64/bin/ 因为我下载的是64位12.13.0版本，并且放到了根目录home下，你可以根据自己的需求进行更改上面的路径。保存退出后，执行命令让修改生效。\nsource ~/.bashrc 然后在终端输入npm -v和node -v验证是否安装配置成功\n$npm -v 6.13.0 $node -v v12.13.0 Windows 下载稳定版或者最新版都可以Node.js，安装选项全部默认，一路点击Next。最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。\nnpm加速 一般国内通过npm下载东西会比较慢，所以需要添加阿里的源进行加速。\nnpm config set registry https://registry.npm.taobao.org 3.安装Git 为了把本地的网页文件上传到Github上面去，我们需要用到分布式版本控制工具 git。关于git和Github这里就不多介绍了。同样分为两个版本：\nLinux 在Linux平台比较方便，直接使用命令就可以安装：\nsudo apt-get install git 安装完成后即可享用。\nWindows 需要去官网下载Git，下载完成后按照向导安装即可。\n 注意：在安装的最后一步添加路径时选择 Use Git from the Windows Command Prompt 。这是把Git添加到了环境变量中，以便可以在cmd中使用。而本人推荐使用下载附带的git bash进行操作，比较方便。\n 对于git的讲解和使用，大家可以自行到网上查找。Hexo搭建的过程中，已经封装好一个git命令，可以直接使用hexo的命令将生成的静态网站代码同步到github的仓库里。但是如果想要自己同步源码的话，那么就需要掌握一下git命令了。在这里我只列举一下常用的命令：\ngit init #初始化一个git库，生成.git文件夹，里面保存的是该git库的记录和配置 git remote add origin 远程仓库地址 #将本地仓库和远程仓库链接起来 git pull #同步代码 git status #检查本地仓库修改状态 git add 文件名 或者 git add . #将本地修改的文件加入缓存 git commit 文件名 -m \u0026#34;描述\u0026#34; 或者 git commit . -m \u0026#34;描述\u0026#34; #提交缓存，并描述该提交 git push -u origin code # 将本地的提交推送到远程仓库.-u是代表输入账号密码，如果你已经配置了git的公钥，那么可直接push. 4.注册Github Git安装完成之后就可以去Github上注册账号并创建仓库， 用来存放我们的网站了。\n Github是基于 Git 做版本控制的代码托管平台，同时也是全球最大的代（同）码（性）托（交）管（友）网站。\n 创建完账户之后新建一个项目仓库New repository，如下所示\n接着输入仓库名，后面一定要加.github.io后缀，README初始化也要勾上。 如下图配置（因为我的已经存在相同的仓库，所以报错）\n 要创建一个和你用户名相同的仓库，后面加.github.io，只有这样将来要部署到GitHub page的时候，才会被识别，也就是http://xxxx.github.io，其中xxx就是你注册GitHub的用户名\n 然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages，点击新出来的链接，就会进入到github page的界面。看到这个界面就说明Github的page已经可以使用了，接下来我们进入Hexo的搭建。\n第二部分：搭建 1.安装Hexo 首先创建一个文件夹，名字自取如YoungBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。在该目录下输入如下命令安装Hexo：\nnpm install -g hexo-cli 接下来初始化一下hexo,即初始化我们的网站，\nhexo init  初始化要求必须是空的目录下进行。\n 接着输入npm install安装必备的组件。\n初始化完成后会在目下生成几个文件和文件夹，这些就是我们需要编写的网站源码了：\n node_modules: 依赖包，npm安装的一些插件存放的文件夹。 public：存放生成的页面，网站正式展示的内容。 scaffolds：生成文章和页面的一些模板。 source：用来存放你的文章和数据。 themes：主题存放文件夹。 _config.yml: 博客的配置文件，非主题的配置。 db.json：博客的版本信息等。 package.json和package-lock.json：依赖包和版本信息。  这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000就可以看到我们的博客啦，效果如下：\n这里介绍一下Hexo常用的几个命令：\nhexo clean #清除db和public文件下的内容，或可写成hexo cl hexo g #根据源码生成静态文件 hexo s #开启本地的server，这样可在本地通过localhost:4000访问博客。或可写成hexo server hexo d #部署网站的静态文件到配置好的托管网站，如Github或者Coding，配置在_config中的Deploy。 #后续如果安装了一些插件，可能导致缩写无法使用，所以hexo d也可以写成hexo deploy。 看完展示后，可以按ctrl+c关闭本地服务器。\n2.部署到Github 首先要安装一个插件，用于Hexo部署代码的。\nnpm i hexo-deployer-git 安装完成之后，在_config.yml配置文件中加入如下代码，这样我们在使用hexo d的时候就可以直接部署到Github上了，如果你想部署到其他平台（支持Git），也可以添加到这里。\ndeploy: type: git repository: https://github.com/hiyoung123/hiyoung123.github.io branch: master  如果不了解git那么请先自行百度学习一下git的相关配置。\n Git分为无密推送和需要输入账户密码推送。无密码推送就是需要在本地生成公钥，然后添加到代码托管平台如Github，这样在推送时候就不需要输入账户密码了。而反之的话，每次推送就会要求你输入账户密码。下面说一下无密推送的配置过程。\n首先打开Git bash，输入如下内容：\ngit config --global user.name \u0026#34;你的用户名\u0026#34; git config --global user.email \u0026#34;你的邮箱\u0026#34; 用户名和邮箱根据你注册github的信息自行修改。\n然后生成密钥SSH key：\nssh-keygen -t rsa -C \u0026#34;你的邮箱\u0026#34; 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。或者git bash中输入\ncat ~/.ssh/id_rsa.pub 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。\n这样你的电脑就跟Github建立起的安全联系，以后推送代码就不需要输入密码了。\n 注意：这里使用hexo d推送代码，推送的是编译完成的静态文件，也就是上面说的public文件夹下的代码，而不是网站的源代码。\n 3.写文章、发布文章 输入hexo new post \u0026quot;article title\u0026quot;，新建一篇文章。\n然后打开\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。\n编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。\n4.绑定个人域名 现在默认的域名还是xxx.github.io，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。\n以我的阿里云为例，如下图所示，添加两条解析记录：\n我添加的是A记录，也就是需要添加IP地址的，你部署到Github的IP可以通过ping xxx.github.io获得。当然也可以添加CNAME记录，记录值填写xxx.github.io即可。\n解析域名完成后，需要在Github上加入你的域名。打开你的github博客项目，点击settings，拉到下面Custom domain处，填上你自己的域名，保存完成后如下图：\n 注意：如果下面的Enforce HTTPS 没有点击的话请勾选上。这个作用是使你的网络请求以更安全的HTTPS方式请求。\n 这时候你的项目根目录应该会出现一个名为CNAME的文件了，如果没有的话，打开你本地博客/source目录，新建CNAME文件，注意没有后缀。然后在里面写上你的域名，保存。因为每次推送代码的时候，都会把Github自动生成的CNAME文件删除掉，导致每次推送后域名和Github就失去了联系，我们在source/下自己创建一个CNAME文件，这样就可以永久保存了。\n5.备份博客源文件 这次我们提交到Github上的是博客的源代码，这样我们就可以在不同电脑上进行操作了。\n首先在github博客仓库下新建一个分支code，然后git clone到本地，把.git文件夹拿出来，放在博客根目录下（也可以博客根目录下执行git init , 然后 git remote add origin 远端仓库地址的方式）。然后git checkout code切换到code分支，然后git add .，然后git commit -m \u0026quot;xxx\u0026quot;，最后git push origin code提交就行了。\n第三部分：定制 这部分主要讲解一下主题的功能定制，除了基本的功能定制外，还有我参考各个大佬们的功能，有些我虽然没有加在我的博客上，但是也列在了此处。所以先在此处感谢一下各位大佬的博客文章。\n闪烁之狐的原版定制 | Godweiyang | 洪卫 | Sky03\n1.更换主题 下载主题，解压到博客目录下的themes目录，修改根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery\n2.设置文章模板 Hexo的页面是包括一个md文件和ejs文件结合而成的，md文件中的内容是页面配置，基本信息，和显示的内容。而ejs文件就是js逻辑代码了。\n我们在scaffolds/post.md中设置文章的默认模板，这样以后创建文章的时候，这些信息就默认添加上了，不同文章你也可以修改这些信息。\n--- title: {{ title }} date: {{ date }} top: false cover: false password: toc: true mathjax: true summary: tags: categories: --- 3.添加404页面 原来的主题没有404页面，所以我们自己添加一个。首先在/source/目录下新建一个404.md，内容如下：\n--- title: 404 date: 2019-07-19 16:41:10 type: \u0026#34;404\u0026#34; layout: \u0026#34;404\u0026#34; description: \u0026#34;你来到了没有知识的荒原 :(\u0026#34; --- 然后在/themes/matery/layout/目录下新建一个404.ejs文件，内容如下：\n\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; /* don\u0026#39;t remove. */ .about-cover { height: 75vh; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;bg-cover pd-header about-cover\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col s10 offset-s1 m8 offset-m2 l8 offset-l2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;brand\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title center-align\u0026#34;\u0026gt; 404 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;description center-align\u0026#34;\u0026gt; \u0026lt;%= page.description %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 每天切换 banner 图. Switch banner image every day. $(\u0026#39;.bg-cover\u0026#39;).css(\u0026#39;background-image\u0026#39;, \u0026#39;url(/medias/banner/\u0026#39; + new Date().getDay() + \u0026#39;.jpg)\u0026#39;); \u0026lt;/script\u0026gt; 4.添加二级菜单 因为我使用的是最新版的主题代码，所以二级菜单可以直接在主题的配置文件_config.yml中配置，而不需要自己添加代码。如果你是老版本的主题，那么你可以参考上述两位大佬的博客进行添加代码。\n# 二级菜单写法如下 Medias: icon: fas fa-list children: - name: Books url: /books icon: fas fa-book - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Galleries url: /galleries icon: fas fa-image 这样我们就可以在导航栏中看见媒体的图标以及二级图标了，不过由于我们没有创建对应的页面，所以无法看见内容。这里只举例说一下musics页面的创建。\n先使用命令创建musics对应的md文件\nhexo new page \u0026#34;musics\u0026#34; 这样就在source目录下生成一个musics目录了，里面包含一个index.md就是musics页面的配置文件了。我们填入对应layout的ejs文件\n--- title: musics date: 2019-11-14 23:41:25 type: \u0026#34;musics\u0026#34; layout: \u0026#34;musics\u0026#34; --- 然后在主题的layout目录下创建ejs文件，并写入如下内容：\n\u0026lt;%- partial(\u0026#39;_partial/bg-cover\u0026#39;) %\u0026gt; \u0026lt;main class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;contact\u0026#34; class=\u0026#34;container chip-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-content\u0026#34; style=\u0026#34;text-align: center\u0026#34;\u0026gt; \u0026lt;h3 style=\u0026#34;margin: 5px 0 5px 5px;\u0026#34;\u0026gt;如果你有好的内容推荐，欢迎在下面留言！\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;% if (theme.gitalk \u0026amp;\u0026amp; theme.gitalk.enable) { %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/gitalk\u0026#39;) %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;% if (theme.gitment.enable) { %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/gitment\u0026#39;) %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;% if (theme.disqus.enable) { %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/disqus\u0026#39;) %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;% if (theme.livere \u0026amp;\u0026amp; theme.livere.enable) { %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/livere\u0026#39;) %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;% if (theme.valine \u0026amp;\u0026amp; theme.valine.enable) { %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/valine\u0026#39;) %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; 这样一个页面就创建好了，具体内容可自行修改，其他页面也是如此创建的。\n 这里有一个bug，就是二级菜单不显示中文，解决方法请见Debug部分。\n 5.图片添加水印 为了防止别人抄袭你文章，可以把所有的图片都加上水印，方法很简单。首先在博客根目录下新建一个watermark.py，代码如下：\n# -*- coding: utf-8 -*- import sys import glob from PIL import Image from PIL import ImageDraw from PIL import ImageFont def watermark(post_name): if post_name == \u0026#39;all\u0026#39;: post_name = \u0026#39;*\u0026#39; dir_name = \u0026#39;source/_posts/\u0026#39; + post_name + \u0026#39;/*\u0026#39; for files in glob.glob(dir_name): im = Image.open(files) if len(im.getbands()) \u0026lt; 3: im = im.convert(\u0026#39;RGB\u0026#39;) print(files) font = ImageFont.truetype(\u0026#39;STSONG.TTF\u0026#39;, max(30, int(im.size[1] / 20))) draw = ImageDraw.Draw(im) draw.text((im.size[0] / 2, im.size[1] / 2), u\u0026#39;@hiyoung\u0026#39;, fill=(0, 0, 0), font=font) im.save(files) if __name__ == \u0026#39;__main__\u0026#39;: if len(sys.argv) == 2: watermark(sys.argv[1]) else: print(\u0026#39;[usage] \u0026lt;input\u0026gt;\u0026#39;) 字体也放根目录下，自己找字体。然后每次写完一篇文章可以运行python3 watermark.py postname添加水印，如果第一次运行要给所有文章添加水印，可以运行python3 watermark.py all。\n 这个代码的逻辑就是从文章目录下拿到图片，添加水印。这个前提是要文章的图片放在source/_posts/下，所以如果在文章中直接引用了其他地方的图片链接，那么这个脚本不会去给那个图片加水印了。\n 6.动态标签栏 这个功能我没有添加，只是简单的一段代码，在theme/matery/layout/layout.ejs下添加如下代码：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var OriginTitile = document.title, st; document.addEventListener(\u0026#34;visibilitychange\u0026#34;, function () { document.hidden ? (document.title = \u0026#34;Σ(っ °Д °;)っ喔哟，崩溃啦！\u0026#34;, clearTimeout(st)) : (document.title = \u0026#34;φ(゜▽゜*)♪咦，又好了！\u0026#34;, st = setTimeout(function () { document.title = OriginTitile }, 3e3)) }) \u0026lt;/script\u0026gt; 7.添加豆瓣插件 我的二级菜单书单和电影都是通过豆瓣插件来添加内容的。\n首先安装插件：\nnpm install hexo-douban --save 将下面的配置写入博客的 _config.yml 文件里：\ndouban: user: #填写你的豆瓣id，打开豆瓣，登入账户，然后在右上角点击 ”个人主页“，url的后面就是id。 builtin: true book: title: \u0026#39;我的无味书屋！\u0026#39; quote: \u0026#39;沉醉于知识的hiyoung.\u0026#39; movie: title: \u0026#39;电影推荐\u0026#39; quote: \u0026#39;沉醉于电影的hiyoung.\u0026#39; #game:　不想要的内容可注释掉 # title: \u0026#39;This is my game title\u0026#39; # quote: \u0026#39;This is my game quote\u0026#39; timeout: 10000 然后创建对应的页面，在页面的ejs文件中添加如下代码：\n\u0026lt;%- partial(\u0026#39;_partial/bg-cover\u0026#39;) %\u0026gt; \u0026lt;style\u0026gt; .hexo-douban-picture img { width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;main class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;contact\u0026#34; class=\u0026#34;container chip-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-content\u0026#34; style=\u0026#34;padding: 30px\u0026#34;\u0026gt; \u0026lt;h1 style=\u0026#34;margin: 10px 0 10px 0px;\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;tag-title center-align\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-book\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;%- page.title %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;%- page.content %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-content\u0026#34; style=\u0026#34;text-align: center\u0026#34;\u0026gt; \u0026lt;h3 style=\u0026#34;margin: 5px 0 5px 5px;\u0026#34;\u0026gt;如果你有好的内容推荐，欢迎在下面留言！\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;% if (theme.gitalk \u0026amp;\u0026amp; theme.gitalk.enable) { %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/gitalk\u0026#39;) %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;% if (theme.gitment.enable) { %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/gitment\u0026#39;) %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;% if (theme.disqus.enable) { %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/disqus\u0026#39;) %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;% if (theme.livere \u0026amp;\u0026amp; theme.livere.enable) { %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/livere\u0026#39;) %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;% if (theme.valine \u0026amp;\u0026amp; theme.valine.enable) { %\u0026gt; \u0026lt;%- partial(\u0026#39;_partial/valine\u0026#39;) %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; 在你的博客文件夹内找到这个文件夹 /node_modules/hexo-douban/lib ，这个文件夹内找到以下三个文件： books-generator.js 、games-generator.js 、movies-generator.js\n将每个文件内最下面的：\nlayout: [\u0026#39;page\u0026#39;, \u0026#39;post\u0026#39;] 改为：\nlayout: [\u0026#39;page\u0026#39;, \u0026#39;books\u0026#39;] books是对应的呈现内容的ejs文件名。这样我们的豆瓣内容就设置完成了，可以进行编译部署了。\n 通常大家都喜欢用 hexo d 来作为 hexo deploy 命令的简化，但是当安装了 hexo douban 之后，就不能用 hexo d 了，因为 hexo douban 跟 hexo deploy 的前缀都是 hexo d ，你以后执行的 hexo d 将不再是 Hexo 页面的生成，而是豆瓣页面的生成。\n这里也说一下这个插件的逻辑，该插件通过你设置的豆瓣id，去爬取豆瓣信息。将爬取到的信息返回给对应的layout，然后进行展示。\n 8.统一友链卡片样式 我不喜欢原版的友链显示，所以统一了颜色，打开themes/matery/layout/friends.ejs文件，找到如下代码并修改：\n\u0026lt;!--修改frends卡片，统一样式 --\u0026gt; \u0026lt;!--\u0026lt;div class=\u0026#34;card frind-card\u0026lt;%- ((i % 10) +1) %\u0026gt;\u0026#34;\u0026gt; 修改前--\u0026gt; \u0026lt;div class=\u0026#34;card frind-card1\u0026#34;\u0026gt; 它的样式颜色也在该文件中，各位可自行修改。\n9.添加交换友链卡片 在/source/friends/index.md文件中添加要交互的信息：\n# 友链交换 想要交换友链的大佬，欢迎在留言板留言，留言格式： * **名称：**Hiyoung * **地址：**https://hiyoungai.com/ * **简介：**宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。 * **头像：**https://cdn.jsdelivr.net/gh/hiyoung123/cdn/img/avatar.jpg 然后在friends.ejs文件中的如下位置添加代码：\n\u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-content article-card-content\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;articleContent\u0026#34; data-aos=\u0026#34;fade-up\u0026#34;\u0026gt; \u0026lt;%- page.content %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;% if (theme.gitalk \u0026amp;\u0026amp; theme.gitalk.enable) { %\u0026gt; 10.修改各菜单首图样式 修改各个页面的首图为本页面标题，而不是统一的网站标题。\n打开layout/_partial/bg-cover-content.ejs文件，找到如下代码：\n\u0026lt;div class=\u0026#34;title center-align\u0026#34;\u0026gt; \u0026lt;% if (config.subtitle \u0026amp;\u0026amp; config.subtitle.length \u0026gt; 0) { %\u0026gt; \u0026lt;%= config.subtitle %\u0026gt; \u0026lt;% } else { %\u0026gt; subtitle \u0026lt;% } %\u0026gt; \u0026lt;/div\u0026gt; 修改为：\n\u0026lt;div class=\u0026#34;title center-align\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;% if (config.subtitle \u0026amp;\u0026amp; config.subtitle.length \u0026gt; 0) { %\u0026gt; \u0026lt;%= config.subtitle %\u0026gt; \u0026lt;% } else { %\u0026gt; subtitle \u0026lt;% } %\u0026gt; --\u0026gt; \u0026lt;% if (is_archive()) { %\u0026gt; \u0026lt;%= __(\u0026#39;archives\u0026#39;) %\u0026gt; \u0026lt;% } else if (is_category()) { %\u0026gt; \u0026lt;%= __(\u0026#39;categories\u0026#39;) %\u0026gt; \u0026lt;% } else if (is_tag()) { %\u0026gt; \u0026lt;%= __(\u0026#39;tag\u0026#39;) %\u0026gt; \u0026lt;% } else if (page.title \u0026amp;\u0026amp; page.title.length \u0026gt; 0) { %\u0026gt; \u0026lt;%= __(page.title) %\u0026gt; \u0026lt;% } else { %\u0026gt; \u0026lt;%= config.subtitle%\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;/div\u0026gt; 11.在文章中添加网易云音乐 首先打开网易云网页版，找到想听的歌曲，然后点击生成外链，复制html代码。粘贴到文章里就行了，为了美观，设置一下居中，具体代码如下：\n\u0026lt;div align=\u0026#34;middle\u0026#34;\u0026gt;这里粘贴刚刚复制的代码\u0026lt;/div\u0026gt; 12.建站时间、卜算子计数、全站文字统计 新版本中已经集成了该功能，可以直接在主题的配置文件_config.yml中进行配置：\n首先需要安装插件：\nnpm i --save hexo-wordcount 然后在_config.yml配置：\nwordCount: enable: false # 将这个值设置为 true 即可. postWordCount: true min2read: true totalCount: true #需要添加这个字段，原版没有　全站文字统计配置 建站时间配置：\n# Website start time. # 站点运行开始时间. time: enable: true year: 2019 # 年份 month: 11 # 月份 date: 12 # 日期 hour: 00 # 小时 minute: 00 # 分钟 second: 00 # 秒 13.关于页面添加简历 修改/themes/matery/layout/about.ejs，找到\u0026lt;div class=\u0026quot;card\u0026quot;\u0026gt;标签，然后找到它对应的\u0026lt;/div\u0026gt;标签，接在后面新增一个card，语句如下：\n\u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-content article-card-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title center-align\u0026#34; data-aos=\u0026#34;zoom-in-up\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-address-book\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;%- __(\u0026#39;myCV\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;articleContent\u0026#34; data-aos=\u0026#34;fade-up\u0026#34;\u0026gt; \u0026lt;%- page.content %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 这样就会多出一张card，然后可以在/source/about/index.md下面写上你的简历了，当然这里的位置随你自己设置，你也可以把简历作为第一个card。\n14.添加评论插件 主题已经自带了gitalk插件了，所以你只需要去github官网配置好就行了。\n首先打开github申请一个应用，要填四个东西：\nApplication name //应用名称，随便填 Homepage URL //填自己的博客地址 Application description //应用描述，随便填 Authorization callback URL //填自己的博客地址 然后点击注册，会出现两个字符串Client ID和Client Secret，这个要复制出来。\n然后去主题的配置文件_config.yml下修改gitalk那里：\ngitalk: enable: true owner: 你的github用户名 repo: 你的github用户名.github.io oauth: clientId: 粘贴刚刚注册完显示的字符串 clientSecret: 粘贴刚刚注册完显示的字符串 admin: 你的github用户名 以后写文章的时候，只要在文章页面登陆过github，就会自动创建评论框，记得每次写完文章后打开博客文章页面一下。\n15.添加RSS插件 npm install hexo-generator-feed --save 在Hexo根目录下的 _config.yml 文件中，新增以下的配置项：\nfeed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: \u0026#39; \u0026#39; order_by: -date 执行 hexo clean \u0026amp;\u0026amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。\n16.添加搜索插件 npm install hexo-generator-search --save 在根目录下的 _config.yml 文件中，新增以下的配置项：\nsearch: path: search.xml field: post 17.添加代码高亮插件 npm i -S hexo-prism-plugin 然后，修改根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下：\nhighlight: enable: false prism_plugin: mode: \u0026#39;preprocess\u0026#39; # realtime/preprocess theme: \u0026#39;tomorrow\u0026#39; line_number: false # default false custom_css: 18.修改打赏功能 在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。\n19.修改页脚 页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。\n20.修改社交链接 在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：\n\u0026lt;% if (theme.socialLink.github) { %\u0026gt; \u0026lt;a href=\u0026#34;\u0026lt;%= theme.socialLink.github %\u0026gt;\u0026#34; class=\u0026#34;tooltipped\u0026#34; target=\u0026#34;_blank\u0026#34; data-tooltip=\u0026#34;访问我的GitHub\u0026#34; data-position=\u0026#34;top\u0026#34; data-delay=\u0026#34;50\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fab fa-github\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;% } %\u0026gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考：\n Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu  21.添加聊天功能 前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。\n前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。\n第四部分：优化 1.URL优化 使用插件优化url，插件hexo-abbrlink实现了这个功能，它将原来的URL地址重新进行了进制转换和再编码。\n安装hexo-abbrlink：\nnpm install hexo-abbrlink --save 配置博客根目录下的_config.yml文件。\n2.CDN优化 用法：\nhttps://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 如本文的图片：\nhttps://cdn.jsdelivr.net/gh/hiyoung123/CDN/img/img_hexo_github_new_rep.png 3.压缩代码 首先安装插件：\nnpm install hexo-neat --save 在根目录配置文件 _config.yml 末尾加入以下配置：\n#hexo-neat 优化提速插件（去掉HTML、css、js的blank字符） neat_enable: true neat_html: enable: true exclude: - \u0026#39;**/*.md\u0026#39; neat_css: enable: true exclude: - \u0026#39;**/*.min.css\u0026#39; neat_js: enable: true mangle: true output: compress: exclude: - \u0026#39;**/*.min.js\u0026#39; - \u0026#39;**/**/instantpage.js\u0026#39; - \u0026#39;**/matery.js\u0026#39; 4.双部署到Coding Github \u0026amp; Coding Pages 双部署,对国内,国外用户进行分流访问,以提升网站的访问速度. Github Pages 的部署前面已经说了,这里就讲一讲 Coding Pages 如何部署.其实与 Github Pages 也类似,先到coding官网注册,创建一个与用户名同名的仓库,添加仓库地址到配置文件中,在根目录_config.yml对应地方添加如下:\ndeploy: - type: git repo: github: https://github.com/hiyoung123/hiyoung123.github.io coding: https://e.coding.net/hiyoung123/hiyoung123.coding.me.git branch: master 5.图片懒加载 安装插件：\nnpm install hexo-lazyload-image --save 然后在根目录配置文件末尾加入以下代码\nlazyload: enable: true onlypost: false # 是否只对文章的图片做懒加载 loadingImg: # eg ./images/loading.gif 但是一般情况下懒加载和gallery插件会发生冲突，结果可能就是点开图片，左翻右翻都是loading image。matery主题的解决方案是：修改 /themes/matery/source/js 中的 matery.js文件\n在第108行加上：\n$(document).find(\u0026#39;img[data-original]\u0026#39;).each(function(){ $(this).parent().attr(\u0026#34;href\u0026#34;, $(this).attr(\u0026#34;data-original\u0026#34;)); }); 做完这步之后，还有点小Bug，首页的logo点击会直接打开logo图，而不是跳到首页。\n伪解决方案：打开 /themes/matery/layout/_partial/header.ejs文件，\n在img和span的两个头加个div：\n\u0026lt;div class=\u0026#34;brand-logo\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026lt;%- url_for() %\u0026gt;\u0026#34; class=\u0026#34;waves-effect waves-light\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;% if (theme.logo !== undefined \u0026amp;\u0026amp; theme.logo.length \u0026gt; 0) { %\u0026gt; \u0026lt;img src=\u0026#34;\u0026lt;%= theme.logo %\u0026gt;\u0026#34; class=\u0026#34;logo-img\u0026#34; alt=\u0026#34;LOGO\u0026#34;\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;span class=\u0026#34;logo-span\u0026#34;\u0026gt;\u0026lt;%- config.title %\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 其实第一次加载后本地都是有缓存的，如果每次都把loading显示出来就不那么好看。所以我们需要对插件进行魔改，让图片稍微提前加载，避开加载动画。\n打开 Hexo根目录\u0026gt;node_modules \u0026gt; hexo-lazyload-image \u0026gt; lib \u0026gt; simple-lazyload.js 文件第9行修改为：\n\u0026amp;\u0026amp; rect.top \u0026lt;= (window.innerHeight +240 || document.documentElement.clientHeight +240) 作用：提前240个像素加载图片；当然这个值也可以根据自己情况修改。\n第五部分：Debug 1.解决部分菜单页面，标签栏不显示中文标题 首先需要去/themes/matery/languages/下，修改default.yml和zh-CN.yml添加对应的文字信息。\n接着在mobile-nav.ejs和navigation.ejs中添加如下代码：\nmenuMap.set(\u0026#34;Medias\u0026#34;, \u0026#34;媒体\u0026#34;); menuMap.set(\u0026#34;Books\u0026#34;, \u0026#34;书单\u0026#34;); menuMap.set(\u0026#34;Musics\u0026#34;, \u0026#34;音乐\u0026#34;); menuMap.set(\u0026#34;Videos\u0026#34;, \u0026#34;视频\u0026#34;); menuMap.set(\u0026#34;Galleries\u0026#34;, \u0026#34;相册\u0026#34;); 找到下面的代码：\n\u0026lt;span\u0026gt;\u0026lt;%- childrenLink.name %\u0026gt;\u0026lt;/span\u0026gt; 修改为：\n\u0026lt;%- (config.language === \u0026#39;zh-CN\u0026#39; \u0026amp;\u0026amp; menuMap.has(childrenLink.name)) ? menuMap.get(childrenLink.name) : childrenLink.name %\u0026gt; 并在head.ejs文件中修改：\nvar title = page.title; // tags, categories, about pages title  if (title == \u0026#39;tags\u0026#39;) { title = __(\u0026#39;tags\u0026#39;); } else if (title == \u0026#39;categories\u0026#39;) { title = __(\u0026#39;categories\u0026#39;); } else if (title == \u0026#39;about\u0026#39;) { title = __(\u0026#39;about\u0026#39;); } else if (title == \u0026#39;contact\u0026#39;) { title = __(\u0026#39;contact\u0026#39;); } else if (title == \u0026#39;friends\u0026#39;) { title = __(\u0026#39;friends\u0026#39;); } else if (title == \u0026#39;musics\u0026#39;) { title = __(\u0026#39;musics\u0026#39;); } else if (title == \u0026#39;galleries\u0026#39;) { title = __(\u0026#39;galleries\u0026#39;); } 2.部署在coding中，使用www.访问域名时，出现404． 需要在coding部署设置中，绑定一下www的域名，同时需要申请证书。\n3.在coding中认证失败 如果申请失败的话，在域名解析处将境外的解析记录关掉，然后再去申请。申请成功后再打开境外的记录。\n4.使用neat插件压缩代码，导致鼠标点击特效消失 在压缩代码插件配置中修改为如下代码：\nneat_js: enable: true mangle: true output: compress: exclude: - \u0026#39;**/*.min.js\u0026#39; - \u0026#39;**/**/instantpage.js\u0026#39; - \u0026#39;**/matery.js\u0026#39; - \u0026#39;**/clicklove.js\u0026#39; #防止影响点击特效 5.卜算子区分www和不带www的域名，导致访问数无法同步。\n卜算子按照域名进行统计，带www和不带www的属于两个域名。可能需要重定向解决。\n使用cloudflare貌似可以做到域名重定向。\n更新 hexo 升级   打开 package.json，修改 dependencies 项：\n\u0026#34;hexo\u0026#34;: \u0026#34;^5.0.0\u0026#34;,   执行更新\nnpm update   更换butterfly主题   clone 项目到 themes 目录\ngit clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/hexo-theme-butterfly   安装对应插件\nnpm install hexo-renderer-pug hexo-renderer-stylus   修改_config.yml文件\n theme: hexo-theme-butterfly   执行构建等命令\nhexo clean \u0026amp; hexo g \u0026amp; hexo s   异常   prettyUrls is not a function\nnpm cache clean --force delete node_modules folder delete package-lock.json file npm install hexo clean; hexo g   鸣谢 再次感谢下面几位大佬的博客：\n闪烁之狐的原版定制 | Godweiyang | 洪卫 | Sky03\n","permalink":"https://hiyoungai.com/posts/%E6%9C%80%E5%85%A8hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BC%98%E5%8C%96%E6%95%99%E7%A8%8B/","summary":"使用Hexo+Github搭建一个免费的个人博客，本文略长，大佬请自行选择阅读。 前言 一边上班一边搭建博客，忙了大概有一周左右的时间，终于把博","title":"最全Hexo博客搭建及优化教程"},{"content":"Arxiv API 允许以编程方式获取 https://arxiv.org 上的论文。API 的基本结构为：\nhttp://export.arxiv.org/api/{method_name}?{parameters} 查询接口 查询接口的的 method_name 为 query，下面是查询方法的参数，参数之间以 \u0026amp; 分隔。\n   parameters type defaults required     search_query string None No   id_list comma-delimited string（以 ‘，’ 分隔的字符串） None No   start int 0 No   max_results int 10 No    参数说明  如果 API 只包含 search_query（不包含 id_list），那么返回与 search_query 内容匹配的结果。 如果 API 只包含 id_list（不包含 search_query），那么返回 id_list 中每一项的结果。 如果 API 中包含了 search_query 和 id_list，那么返回在 id_list 中，并且与 search_query 匹配的文章。  分页查询 通常情况下，一个查询可能有成百上千个返回结果。有时候我们不希望一次性查询到这么多数量，那么可以使用 start 和 max_results 两个字段来进行分页查询。\n start 是查询的起始索引，以 0 为第一个。 max_results 是查询返回的集合数。  下面来举例说明一下：\nhttp://export.arxiv.org/api/query?search_query=all:electron\u0026amp;start=0\u0026amp;max_results=10 (1) http://export.arxiv.org/api/query?search_query=all:electron\u0026amp;start=10\u0026amp;max_results=10 (2) http://export.arxiv.org/api/query?search_query=all:electron\u0026amp;start=20\u0026amp;max_results=10 (3) 查询结果分别为：\n 0 - 9 10 - 19 20 - 29  需要注意的是，由于 API 的限制，在多次调用 API 的情况下，建议每次调用的时间间隔为 3 秒。每次调用返回的最大数量为 2000 个。arXiv的硬限制约为 50,000 条记录； 对于与 50,000 多个原稿匹配的查询，无法接收全部结果. 解决这个问题的最简单的解决方案是将中断查询成小块，例如使用的时间片，与一系列日期的submittedDate或lastUpdatedDate 。\n排序查询 对查询的结果进行排序有两个选项：sortBy 和 sortOrder。\n sortBy 的值有：relevance，lastUpdatedDate 和 submittedDate。 sortOrder 的值有：ascending 和 descending。  示例：\nhttp://export.arxiv.org/api/query?search_query=ti:%22electron%20thermal%20conductivity%22\u0026amp;sortBy=lastUpdatedDate\u0026amp;sortOrder=ascending 结果响应 API 的 Response 内容中是以 Atom 1.0 为主体的，Atom 是 XML 的一种语法。下面分别来说明各个标签的含义。\nFeed Metadata 每个 Response 都会包含的内容：\n 版本和命名空间  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;feed xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; Title：feed 的标题，通常为查询 URL 的字符串。  \u0026lt;title xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; ArXiv Query: search_query=all:electron\u0026amp;amp;id_list=\u0026amp;amp;start=0\u0026amp;amp;max_results=1 \u0026lt;/title\u0026gt; Id：查询的唯一标识（注意不是查询的每个文章的 id），保证每个查询 id 是唯一的。  \u0026lt;id xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; http://arxiv.org/api/cHxbiOdZaP56ODnBPIenZhzg5f8 \u0026lt;/id\u0026gt; Link：查询 URL 的规范化。  \u0026lt;link xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34; href=\u0026#34;http://arxiv.org/api/query?search_query=all:electron\u0026amp;amp;id_list=\u0026amp;amp;start=0\u0026amp;amp;max_results=1\u0026#34; rel=\u0026#34;self\u0026#34; type=\u0026#34;application/atom+xml\u0026#34;/\u0026gt; Updated：提供了 feed 内容最后一次更新的时间。  \u0026lt;updated xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt;2007-10-08T00:00:00-04:00\u0026lt;/updated\u0026gt; Opensearch：扩展元素，包含了查询的返回数量以及分页信息等。  \u0026lt;opensearch:totalResults xmlns:opensearch=\u0026#34;http://a9.com/-/spec/opensearch/1.1/\u0026#34;\u0026gt; 1000 \u0026lt;/opensearch:totalResults\u0026gt; \u0026lt;opensearch:startIndex xmlns:opensearch=\u0026#34;http://a9.com/-/spec/opensearch/1.1/\u0026#34;\u0026gt; 0 \u0026lt;/opensearch:startIndex\u0026gt; \u0026lt;opensearch:itemsPerPage xmlns:opensearch=\u0026#34;http://a9.com/-/spec/opensearch/1.1/\u0026#34;\u0026gt; 1 \u0026lt;/opensearch:itemsPerPage\u0026gt; Entry Metadata 正常情况下，Response 返回结果中的 feed 标签会包含 0 个或者多个 entry 标签。每个 entry 表示一个查询的返回文章，下面分别说一下 entry 中的各个元素。\n Title：返回文章的标题  \u0026lt;title xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; Multi-Electron Production at High Transverse Momenta in ep Collisions at HERA \u0026lt;/title\u0026gt; Id：文章的 URL ，可以认为是文章的绝对路径。最后一个字段是文章的唯一标识符。  \u0026lt;id xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; http://arxiv.org/abs/hep-ex/0307015 \u0026lt;/id\u0026gt; Published/Updated：文章的发布日期和更新日期。  \u0026lt;published xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; 2007-02-27T16:02:02-05:00 \u0026lt;/published\u0026gt; \u0026lt;updated xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; 2007-06-25T17:09:59-04:00 \u0026lt;/updated\u0026gt; Summary：文章的摘要。  \u0026lt;summary xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; Multi-electron production is studied at high electron transverse momentum in positron- and electron-proton collisions using the H1 detector at HERA. The data correspond to an integrated luminosity of 115 pb-1. Di-electron and tri-electron event yields are measured. Cross sections are derived in a restricted phase space region dominated by photon-photon collisions. In general good agreement is found with the Standard Model predictions. However, for electron pair invariant masses above 100 GeV, three di-electron events and three tri-electron events are observed, compared to Standard Model expectations of 0.30 \\pm 0.04 and 0.23 \\pm 0.04, respectively. \u0026lt;/summary\u0026gt; Author：文章的作者，包含一个或者多个 name 标签，分别表示多个作者。  \u0026lt;author xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; \u0026lt;name xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt;H1 Collaboration\u0026lt;/name\u0026gt; \u0026lt;/author\u0026gt; Category：文章的分类。  \u0026lt;category xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34; term=\u0026#34;cs.LG\u0026#34; scheme=\u0026#34;http://arxiv.org/schemas/atom\u0026#34;/\u0026gt; \u0026lt;category xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34; term=\u0026#34;cs.AI\u0026#34; scheme=\u0026#34;http://arxiv.org/schemas/atom\u0026#34;/\u0026gt; \u0026lt;category xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34; term=\u0026#34;I.2.6\u0026#34; scheme=\u0026#34;http://arxiv.org/schemas/atom\u0026#34;/\u0026gt; Link，对于每个文章，最多有三个 link 元素，通过 ref 和 title 来区别，下面的表格表示 ref 和 title 的内容：     rel title refers to always present     alternate - abstract page yes   related pdf pdf yes   related doi resolved doi no    例子：\n\u0026lt;link xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34; href=\u0026#34;http://arxiv.org/abs/hep-ex/0307015v1\u0026#34; rel=\u0026#34;alternate\u0026#34; type=\u0026#34;text/html\u0026#34;/\u0026gt; \u0026lt;link xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34; title=\u0026#34;pdf\u0026#34; href=\u0026#34;http://arxiv.org/pdf/hep-ex/0307015v1\u0026#34; rel=\u0026#34;related\u0026#34; type=\u0026#34;application/pdf\u0026#34;/\u0026gt; \u0026lt;link xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34; title=\u0026#34;doi\u0026#34; href=\u0026#34;http://dx.doi.org/10.1529/biophysj.104.047340\u0026#34; rel=\u0026#34;related\u0026#34;/\u0026gt; arxiv:primary_category：主要分类的扩展元素。  \u0026lt;arxiv:primary_category xmlns:arxiv=\u0026#34;http://arxiv.org/schemas/atom\u0026#34; term=\u0026#34;cs.LG\u0026#34; scheme=\u0026#34;http://arxiv.org/schemas/atom\u0026#34;/\u0026gt; arxiv:comment：评论扩展元素。  \u0026lt;arxiv:comment xmlns:arxiv=\u0026#34;http://arxiv.org/schemas/atom\u0026#34;\u0026gt; 23 pages, 8 figures and 4 tables \u0026lt;/arxiv:comment\u0026gt; arxiv:affiliation：作者从属关系。  \u0026lt;author\u0026gt; \u0026lt;name\u0026gt;G. G. Kacprzak\u0026lt;/name\u0026gt; \u0026lt;arxiv:affiliation xmlns:arxiv=\u0026#34;http://arxiv.org/schemas/atom\u0026#34;\u0026gt;NMSU\u0026lt;/arxiv:affiliation\u0026gt; \u0026lt;/author\u0026gt; arxiv:journal_ref：期刊说明  \u0026lt;arxiv:journal_ref xmlns:arxiv=\u0026#34;http://arxiv.org/schemas/atom\u0026#34;\u0026gt; Eur.Phys.J. C31 (2003) 17-29 \u0026lt;/arxiv:journal_ref\u0026gt; arxiv:doi：doi 说明  \u0026lt;arxiv:doi xmlns:arxiv=\u0026#34;http://arxiv.org/schemas/atom\u0026#34;\u0026gt; 10.1529/biophysj.104.047340 \u0026lt;/arxiv:doi\u0026gt; Errors 返回错误，如果请求的响应出现错误，会返回一个详细的错误信息。例如下面是一个错误 id 的信息：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;feed xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34; xmlns:opensearch=\u0026#34;http://a9.com/-/spec/opensearch/1.1/\u0026#34;\u0026gt; \u0026lt;link xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34; href=\u0026#34;http://arxiv.org/api/query?search_query=\u0026amp;amp;id_list=1234.12345\u0026#34; rel=\u0026#34;self\u0026#34; type=\u0026#34;application/atom+xml\u0026#34;/\u0026gt; \u0026lt;title xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt;ArXiv Query: search_query=\u0026amp;amp;id_list=1234.12345\u0026lt;/title\u0026gt; \u0026lt;id xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt;http://arxiv.org/api/kvuntZ8c9a4Eq5CF7KY03nMug+Q\u0026lt;/id\u0026gt; \u0026lt;updated xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt;2007-10-12T00:00:00-04:00\u0026lt;/updated\u0026gt; \u0026lt;opensearch:totalResults xmlns:opensearch=\u0026#34;http://a9.com/-/spec/opensearch/1.1/\u0026#34;\u0026gt;1\u0026lt;/opensearch:totalResults\u0026gt; \u0026lt;opensearch:startIndex xmlns:opensearch=\u0026#34;http://a9.com/-/spec/opensearch/1.1/\u0026#34;\u0026gt;0\u0026lt;/opensearch:startIndex\u0026gt; \u0026lt;opensearch:itemsPerPage xmlns:opensearch=\u0026#34;http://a9.com/-/spec/opensearch/1.1/\u0026#34;\u0026gt;1\u0026lt;/opensearch:itemsPerPage\u0026gt; \u0026lt;entry xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; \u0026lt;id xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt;http://arxiv.org/api/errors#incorrect_id_format_for_1234.12345\u0026lt;/id\u0026gt; \u0026lt;title xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt;Error\u0026lt;/title\u0026gt; \u0026lt;summary xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt;incorrect id format for 1234.12345\u0026lt;/summary\u0026gt; \u0026lt;updated xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt;2007-10-12T00:00:00-04:00\u0026lt;/updated\u0026gt; \u0026lt;link xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34; href=\u0026#34;http://arxiv.org/api/errors#incorrect_id_format_for_1234.12345\u0026#34; rel=\u0026#34;alternate\u0026#34; type=\u0026#34;text/html\u0026#34;/\u0026gt; \u0026lt;author xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; \u0026lt;name xmlns=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt;arXiv api core\u0026lt;/name\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;/feed\u0026gt; 下面提供了一些常见的错误：\n   Sample query 示例查询 Error Explanation 错误解释     http://export.arxiv.org/api/query?start=not_an_int start 一定是个整数   http://export.arxiv.org/api/query?start=-1 start 必须 \u0026gt;= 0   http://export.arxiv.org/api/query?max_results=not_an_int max_results 一定是个整数   http://export.arxiv.org/api/query?max_results=-1 max_results 必须 \u0026gt;= 0   http://export.arxiv.org/api/query?id_list=1234.1234 malformed id   http://export.arxiv.org/api/query?id_list=cond—mat/0709123 malformed id    例子 Python python2.7 上的简单请求：\nimport urllib url = \u0026#39;http://export.arxiv.org/api/query?search_query=all:electron\u0026amp;start=0\u0026amp;max_results=1\u0026#39; data = urllib.urlopen(url).read() print data python3 上的请求：\nimport urllib.request as libreq with libreq.urlopen(\u0026#39;http://export.arxiv.org/api/query?search_query=all:electron\u0026amp;start=0\u0026amp;max_results=1\u0026#39;) as url: r = url.read() print(r) 附录 查询的详细结构 在 arXiv 搜索引擎中，每篇文章都被划分为许多可以单独搜索的字段。 例如，可以搜索一篇文章的标题，以及作者列表、摘要、评论和期刊参考文献。 要搜索其中一个字段，只需在搜索词前加上字段前缀和冒号即可。 例如：\nhttp://export.arxiv.org/api/query?search_query=au:del_maestro 下面的表格显示所有字段的前缀：\n   prefix explanation     ti Title   au Author   abs Abstract   co Comment   jr Journal Reference   cat Subject Category   rn Report Number   id Id (use id_list instead)   all All of the above    并且查询也支持布尔运算，假设我们希望找到作者 Adrian DelMaestro 的所有文章，其标题中也包含单词 checkerboard。 我们可以使用 AND 操作符构造下面的查询：\nhttp://export.arxiv.org/api/query?search_query=au:del_maestro+AND+ti:checkerboard 下面是三种可能的布尔值：\n AND OR ANDNOT  下面是特殊符号的含义以及转义字符：\n   symbol encoding explanation     ( ) %28 %29 用于为布尔运算符优先级对布尔表达式进行分组   \u0026quot; \u0026quot; %22 %22 用于将多个单词组合成短语以搜索特定字段   空格 + 用于扩展search_query 包含多个字段    返回的详细结构 下表列出了返回的 Atom 结果的每个元素:\n   element explanation     feed elements    title 包含规范化查询字符串的标题   id 分配给此查询的唯一 id   updated 最后一次更新此查询的搜索结果。 设置为当天的午夜   link 通过 GET 请求检索此提要的 url   opensearch:totalResults 此查询的搜索结果总数   opensearch:startIndex 总结果列表中第一个返回结果的基于0的索引   opensearch:itemsPerPage 每页返回的结果数   entry elements    title 文章的标题   id 文章的网址http://arxiv.org/abs/id   published 文章的发布日期   updated 文章的更新日期，如果为 v1 版本，那么与发布日期相同   summary 文章摘要   author 每个作者有一个子元素 name，包含了作者的名字   link 可以给定与这篇文章关联的 3 个网址   category 文章分类   arxiv:primary_category 主要的 arXiv 分类   arxiv:comment 作者对此发表的评论   arxiv:affiliation 作者的从属关系   arxiv:journal_ref 参考文献   arxiv:doi 已解析的 DOI 的 url，指向外部资源    学科的分类 下面是学科分类字段以及对应的翻译（软件脚本自动翻译，如不对请勿喷）：\n   字段 学科（英文） 学科（中文）     astro-ph Astrophysics 天体物理   astro-ph.CO Cosmology and Nongalactic Astrophysics 宇宙学与非规则天体物理学   astro-ph.EP Earth and Planetary Astrophysics 地球与行星天体物理学   astro-ph.GA Astrophysics of Galaxies 星系的天体物理学   astro-ph.HE High Energy Astrophysical Phenomena 高能天体物理现象   astro-ph.IM Instrumentation and Methods for Astrophysics 天体物理学的仪器和方法   astro-ph.SR Solar and Stellar Astrophysics 太阳与恒星天体物理学   cond-mat.dis-nn Disordered Systems and Neural Networks 无序系统与神经网络   cond-mat.mes-hall Mesoscale and Nanoscale Physics 中尺度和纳米尺度物理学   cond-mat.mtrl-sci Materials Science 材料科学   cond-mat.other Other Condensed Matter 其他凝聚态   cond-mat.quant-gas Quantum Gases 量子气体   cond-mat.soft Soft Condensed Matter 软凝聚物   cond-mat.stat-mech Statistical Mechanics 统计力学   cond-mat.str-el Strongly Correlated Electrons 强关联电子   cond-mat.supr-con Superconductivity 超导现象   cs.AI Artificial Intelligence 人工智能   cs.AR Hardware Architecture 硬件架构   cs.CC Computational Complexity 计算复杂性   cs.CE Computational Engineering, Finance, and Science 计算工程，金融和科学   cs.CG Computational Geometry 计算几何   cs.CL Computation and Language 计算与语言   cs.CR Cryptography and Security 密码学与保安   cs.CV Computer Vision and Pattern Recognition 计算机视觉与模式识别   CY Computers and Society 电脑与社会   cs.DB Databases 数据库   cs.DC Distributed, Parallel, and Cluster Computing 分布式、并行和集群计算   cs.DL Digital Libraries 数字仓库   cs.DM Discrete Mathematics 离散数学   cs.DS Data Structures and Algorithms 数据结构和算法   cs.ET Emerging Technologies 新兴科技   cs.FL Formal Languages and Automata Theory 形式语言与自动机理论   cs.GL General Literature 一般文学   cs.GR Graphics 图形   cs.GT Computer Science and Game Theory 计算机科学与博弈论   cs.HC Human-Computer Interaction 人机交互   cs.IR Information Retrieval 信息检索   cs.IT Information Theory 信息理论   cs.LG Learning 学习   cs.LO Logic in Computer Science 计算机科学中的逻辑   cs.MA Multiagent Systems 多代理系统   cs.MM Multimedia 多媒体   cs.MS Mathematical Software 数学软件   cs.NA Numerical Analysis 数值分析   cs.NE Neural and Evolutionary Computing 神经和进化计算   cs.NI Networking and Internet Architecture 网络与互联网架构   cs.OH Other Computer Science 其他计算机科学   cs.OS Operating Systems 操作系统   cs.PF Performance 性能   cs.PL Programming Languages 编程语言   cs.RO Robotics 机器人技术   cs.SC Symbolic Computation 符号计算   cs.SD Sound 声音   cs.SE Software Engineering 软件工程   cs.SI Social and Information Networks 社会和信息网络   cs.SY Systems and Control 系统及控制   econ.EM Econometrics 计量经济学   eess.AS Audio and Speech Processing 音频及语音处理   eess.IV Image and Video Processing 图像和视频处理   eess.SP Signal Processing 信号处理   gr-qc General Relativity and Quantum Cosmology 广义相对论和量子宇宙学   hep-ex High Energy Physics - Experiment 高能物理实验   hep-lat High Energy Physics - Lattice 高能物理-晶格   hep-ph High Energy Physics - Phenomenology 高能物理-现象学   hep-th High Energy Physics - Theory 高能物理理论   math.AC Commutative Algebra 交换代数   math.AG Algebraic Geometry 代数几何   math.AP Analysis of PDEs 偏微分方程分析   math.AT Algebraic Topology 代数拓扑   math.CA Classical Analysis and ODEs 传统分析和微分方程   math.CO Combinatorics 组合数学   math.CT Category Theory 范畴理论   math.CV Complex Variables 复杂变量   math.DG Differential Geometry 微分几何   math.DS Dynamical Systems 动力系统   math.FA Functional Analysis 功能分析   math.GM General Mathematics 普通数学   math.GN General Topology 点集拓扑学   math.GR Group Theory 群论   math.GT Geometric Topology 几何拓扑学   math.HO History and Overview 历史和概述   math.IT Information Theory 信息理论   math.KT K-Theory and Homology K 理论与同调   math.LO Logic 逻辑   math.MG Metric Geometry 度量几何学   math.MP Mathematical Physics 数学物理   math.NA Numerical Analysis 数值分析   math.NT Number Theory 数论   math.OA Operator Algebras 算子代数   math.OC Optimization and Control 优化和控制   math.PR Probability 概率   math.QA Quantum Algebra 量子代数   math.RA Rings and Algebras 环与代数   math.RT Representation Theory 表示论   math.SG Symplectic Geometry 辛几何   math.SP Spectral Theory 光谱理论   math.ST Statistics Theory 统计学理论   math-ph Mathematical Physics 数学物理   nlin.AO Adaptation and Self-Organizing Systems 适应与自组织系统   nlin.CD Chaotic Dynamics 混沌动力学   nlin.CG Cellular Automata and Lattice Gases 元胞自动机与格子气体   nlin.PS Pattern Formation and Solitons 模式形成与孤子   nlin.SI Exactly Solvable and Integrable Systems 严格可解可积系统   nucl-ex Nuclear Experiment 核试验   nucl-th Nuclear Theory 核理论   physics.acc-ph Accelerator Physics 加速器物理学   physics.ao-ph Atmospheric and Oceanic Physics 大气和海洋物理学   physics.app-ph Applied Physics 应用物理学   physics.atm-clus Atomic and Molecular Clusters 原子和分子团簇   physics.atom-ph Atomic Physics 原子物理学   physics.bio-ph Biological Physics 生物物理学   physics.chem-ph Chemical Physics 化学物理   physics.class-ph Classical Physics 经典物理学   physics.comp-ph Computational Physics 计算物理学   physics.data-an Data Analysis, Statistics and Probability 数据分析、统计和概率   physics.ed-ph Physics Education 物理教育   physics.flu-dyn Fluid Dynamics 流体动力学   physics.gen-ph General Physics 普通物理   physics.geo-ph Geophysics 地球物理学   physics.hist-ph History and Philosophy of Physics 物理学的历史与哲学   physics.ins-det Instrumentation and Detectors 仪器和探测器   physics.med-ph Medical Physics 医学物理学   physics.optics Optics 光学   physics.plasm-ph Plasma Physics 等离子体物理   physics.pop-ph Popular Physics 大众物理   physics.soc-ph Physics and Society 物理学与社会   physics.space-ph Space Physics 空间物理学   q-bio.BM Biomolecules 生物分子   q-bio.CB Cell Behavior 细胞行为   q-bio.GN Genomics 基因组学   q-bio.MN Molecular Networks 分子网络   q-bio.NC Neurons and Cognition 神经元与认知   q-bio.OT Other Quantitative Biology 其他定量生物学   q-bio.PE Populations and Evolution 种群与进化   q-bio.QM Quantitative Methods 定量方法   q-bio.SC Subcellular Processes 亚细胞突起   q-bio.TO Tissues and Organs 组织和器官   q-fin.CP Computational Finance 金融工程   q-fin.EC Economics 经济学   q-fin.GN General Finance 财务概述   q-fin.MF Mathematical Finance 数学金融   q-fin.PM Portfolio Management 投资组合管理   q-fin.PR Pricing of Securities 证券定价   q-fin.RM Risk Management 风险管理   q-fin.ST Statistical Finance 金融统计   q-fin.TR Trading and Market Microstructure 交易与市场微观结构   quant-ph Quantum Physics 量子物理学   stat.AP Applications 应用   stat.CO Computation 计算   stat.ME Methodology 方法论   stat.ML Machine Learning 机器学习   stat.OT Other Statistics 其他统计学   stat.TH Statistics Theory 统计学理论    ","permalink":"https://hiyoungai.com/posts/arxiv%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/","summary":"Arxiv API 允许以编程方式获取 https://arxiv.org 上的论文。API 的基本结构为： http://export.arxiv.org/api/{method_name}?{parameters} 查询接口 查询接口的的 method_name 为 query，下面是查询方法的参数，参数之间以 \u0026amp; 分隔。 parameters type defaults required","title":"Arxiv学术论文查询接口详解"},{"content":"遗传算法 遗传算法（$GA$）：是一种基于自然选择和群体遗传机制的搜索算法，它模拟了自然选择和自然遗传过程中的繁殖，杂交和突变的现象．\n 能够生存下来的往往不是最强大的物种，也不是最聪明的物种，而是最能适应环境的物种。\n​\t- 查尔斯·达尔文\n 求解思想  利用遗传算法求解问题时，随机产生一些个体（问题的解）， 根据预定的目标函数对每一个个体进行评估，给出一个适应度，选择一些个体用来产生下一代个体．选择操作体现了适者生存的原理，好的个体被用来产生下一代，坏的个体被淘汰． 然后选择出来的个体经过杂交，突变再组合产生新的个体  遗传操作  选择  选择是指从群体中选择优良的个体并淘汰劣质的个体，他建立在适应度评估的基础上．适应度越大的个体，被选中的概率越大，他的子孙在下一代中的数量越多． 选择的方法有：轮赌盘方法，最佳个体保留法，期望值法，排序选择法，竞争法，线性标准化法．   交叉  交叉是指把两个父代个体的部分结构加以替换组合而生成新的个体的操作，交叉的目的是为了产生下一代新的个体．通过交叉操作，遗传算法的搜索能力得到飞跃的提升． 交叉是遗传算法获取优良个体的重要手段，交叉操作是按照一定的交叉概率在匹配库中随机的选取两个个体进行的，交叉的位置也是随机的，交叉概率一般取得很大 $0.6~0.9$.   变异  变异是以很小的概率 $p$ 随机改变种群中个体的某些基因的值 变异操作的过程是：  产生一个$［０，１］$之间的随机数 $rand$． 如果 $rand \u0026lt; p$ ，则进变异操作．   变异操作本身是一种局部随机搜索，与选择和交叉结合一起使用，能够避免由于选择和交叉导致某些局部信息永久丢失，保证了遗传算法的有效性．保证了群体多样性． 变异概率不宜取过大，如果 $p \u0026gt; 0.5$ ，那么遗传算法退化为随机搜索．    应用 遗传算法是一种迭代的选择算法，从初始解，以及后续繁殖出来的子解中选择最优的解．通常的做法是，将问题的解转化为二进制表示，然后进行遗传算法选择最优解．\n 特征选择：每个特征用二进制中的位表示，$０$ 不选择该特征，$1$ 选择该特征．则有多组特征选择，用遗传算法进行选择最优解. 背包问题 路线规划  python 相关库  tpot：树形传递优化技术  参考  遗传算法的基本原理 一文读懂遗传算法工作原理（附Python实现） 超详细的遗传算法(Genetic Algorithm)解析 遗传算法有哪些比较直观的应用呢？ （列举一些有用的应用和蛋疼的应用，比如用于搜索神经网络参数以及k-mean的ｋ值都是比较蛋疼的．．．） Genetic Drawing 攻击神经网络 遗传算法有哪些有趣应用？ 如何通俗易懂地解释遗传算法？有什么例子？  ","permalink":"https://hiyoungai.com/posts/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/","summary":"遗传算法 遗传算法（$GA$）：是一种基于自然选择和群体遗传机制的搜索算法，它模拟了自然选择和自然遗传过程中的繁殖，杂交和突变的现象． 能够生存","title":"遗传算法"},{"content":"中文分词概述 词是最小的能够独立活动的有意义的语言成分，一般分词是自然语言处理的第一项核心技术。英文中每个句子都将词用空格或标点符号分隔开来，而在中文中很难对词的边界进行界定，难以将词划分出来。在汉语中，虽然是以字为最小单位，但是一篇文章的语义表达却仍然是以词来划分的。因此处理中文文本时，需要进行分词处理，将句子转为词的表示，这就是中文分词。\n中文分词的三个难题 分词规则，消除歧义和未登录词识别：\n 构建完美的分词规则便可以将所有的句子正确的划分，但是这根本无法实现，语言是长期发展自然而然形成的，而且语言规则庞大复杂，很难做出完美的分词规则。 在中文句子中，很多词是由歧义性的，在一句话也可能有多种分词方法。比如：”结婚/的/和尚/未结婚/的“，“结婚/的/和/尚未/结婚/的”，人分辨这样的句子都是问题，更何况是机器。 此外对于未登陆词，很难对其进行正确的划分。  目前主流分词方法 基于规则，基于统计以及二者混合。本篇主要介绍一下基于规则词典进行分词。\n基于规则的分词 主要是人工建立词库也叫做词典，通过词典匹配的方式对句子进行划分。其实现简单高效，但是对未登陆词很难进行处理。主要有正向最大匹配法，逆向最大匹配法以及双向最大匹配法。\n正向最大匹配法FMM FMM的步骤是：\n 从左向右取待分汉语句的m个字作为匹配字段，m为词典中最长词的长度。 查找词典进行匹配。 若匹配成功，则将该字段作为一个词切分出去。 若匹配不成功，则将该字段最后一个字去掉，剩下的字作为新匹配字段，进行再次匹配。 重复上述过程，直到切分所有词为止。  代码实现：\ndef cut(self,text): result = [] index = 0 text_size = len(text) while text_size \u0026gt; index: for size in range(self.window_size+index,index,-1): piece = text[index:size] if piece in self.word_dict:　#查看是否存在于词典中 index = size - 1 break index = index + 1 result.append(piece) return result 分词效果：\n逆向最大匹配法RMM RMM的基本原理与FMM基本相同，不同的是分词的方向与FMM相反。RMM是从待分词句子的末端开始，也就是从右向左开始匹配扫描，每次取末端m个字作为匹配字段，匹配失败，则去掉匹配字段前面的一个字，继续匹配。\n代码实现：\ndef cut(self,text): result = [] index = len(text) window_size = min(index,self.window_size) while index \u0026gt; 0: for size in range(index-window_size,index): piece = text[size:index] if piece in self.word_dict:　#查看是否存在于词典中 index = size + 1 break index = index - 1 result.append(piece) result.reverse()　#因为是从后向前分词，所以需要将结果逆序 return result 分词效果：\n双向最大匹配法Bi-MM Bi-MM是将正向最大匹配法得到的分词结果和逆向最大匹配法得到的结果进行比较，然后按照最大匹配原则，选取词数切分最少的作为结果。据SunM.S.和Benjamin K.T.(1995)的研究表明，中文中90.0%左右的句子，正向最大匹配法和逆向最大匹配法完全重合且正确，只有大概9.0%的句子两种切分方法得到的结果不一样，但其中必有一个是正确的（歧义检测成功），只有不到1.0%的句子，使用正向最大匹配法和逆向最大匹配法的切分虽然重合但是错的，或者两种方法切分不同但结果都不对（歧义检测失败）。\n双向最大匹配的规则是：\n 如果正反向分词结果词数不同，则取分词数量少的那个。 如果分词结果词数相同：  分词结果相同，没有歧义，返回任意一个。 分词结果不同，返回其中单字数量较少的那个。    上述例子中词数相同，但结果不同，逆向最大匹配法的分词结果单字个数是1，所以返回的是逆向最大匹配法的结果。\n代码实现：\ndef cut(self,text): res_fmm = self.FMM.cut(text) res_rmm = self.RMM.cut(text) if len(res_fmm) == len(res_rmm): if res_fmm == res_rmm : return res_fmm else: f_word_count = len([w for w in res_fmm if len(w)==1]) r_word_count = len([w for w in res_rmm if len(w)==1]) return res_fmm if f_word_count \u0026lt; r_word_count else res_rmm else: return res_fmm if len(res_fmm) \u0026lt; len(res_rmm) else res_rmm 分词效果：\n可能有人会问，如果单字的数量也相同怎么办？如果你明白了中文分词的原理和实际用处的话，那么这个问题的答案自然会知晓。中文分词目前仍然没有完全准确的结果，一句话可以分成不同的分词结果。如果单字数量也相同，按照正常的逻辑那么会继续比较双字词，但是这样却没有可比性，在中文中大多数都是双字词，所以即使双字词的数量相同，但是结果可能却有很多种可能。\n我们比较单字词的数量，取数量少的那个结果，只是为了大概率更准确一些，因为中文字单字为词的情况比较少，大多数是双字或多字词。但是针对一些特殊的句子，这种判断方法不见得结果是最优的。虽然如此，但是基于规则的中文分词仍然是目前为止最简单高效的方法。\n总结 基于规则的分词，一般较为简单高效，但是词典的维护很大的人力维护，同时对于未登录词也没有很好的解决办法。双向最大匹配结合了正反两种方法的结果，结果较为准确，在实用中文信息处理中使用广泛。\n参考  《Python自然语言处理实战-核心技术与算法》涂铭，刘祥，刘树春 著 《统计自然语言处理》 宗成庆 著 详细代码可参考 GitHub  ","permalink":"https://hiyoungai.com/posts/%E5%9F%BA%E4%BA%8E%E8%AF%8D%E5%85%B8%E7%9A%84%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E7%AE%97%E6%B3%95/","summary":"中文分词概述 词是最小的能够独立活动的有意义的语言成分，一般分词是自然语言处理的第一项核心技术。英文中每个句子都将词用空格或标点符号分隔开来，","title":"基于词典的中文分词算法"},{"content":"简介 Goldendict 是一款跨平台的翻译软件，支持划词翻译等功能。它更像一种词典或者词典的API工具，通过外挂好本地词典或者网站词典进行翻译，返回的样式就是设置词典的样式。\nGolendict 有以下几大特点：\n 自定义词本地典库，可加载外挂词典，可自定义分组； 自定义在线词典和百科； 支持屏幕取词（虽然有时不是很灵），但搭配上 Autohotkey 无敌； 支持全文搜索，有生词本且可导出。  官方效果图：\n安装 这里主要介绍一下 Ubuntu 下的安装，其他平台的安装进入官网自行查看。\n在 Ubuntu 上安装 Goldendict 比较简单，直接在命令行输入如下命令即可：\nsudo apt-get install goldendict 配置 添加在线词典 我们可以通过如下步骤添加在线词典，左上角菜单栏找到“编辑“选项,然后 编辑-\u0026gt;词典-\u0026gt;网站-\u0026gt;添加：\n如何获取到在线词典呢？百度搜索必应词典，随便搜索一个单词，例如 welcome，会得到一个网址： http://cn.bing.com/dict/search?q=welcome\u0026amp;;qs=n\u0026amp;;form=Z9LH5\u0026amp;;pq=welcome\u0026amp;;sc=0-7\u0026amp;;sp=-1\u0026amp;;sk=\u0026amp;;cvid=127D88B2AD4E4842A79BCB32B430FC33 然后将其中的 welcome 全部替换成 %GDWORD% 得到： http://cn.bing.com/dict/search?q=%GDWORD%\u0026amp;;qs=n\u0026amp;;form=Z9LH5\u0026amp;;pq=%GDWORD%\u0026amp;;sc=0-7\u0026amp;;sp=-1\u0026amp;;sk=\u0026amp;;cvid=127D88B2AD4E4842A79BCB32B430FC33\n 有道： http://dict.youdao.com/search?q=%GDWORD%\u0026amp;ue=utf8 必应： http://cn.bing.com/dict/search?q=%GDWORD% 海词：http://dict.cn/%GDWORD%  需要注意的是，添加完在线词典之后需要勾选上才可以使用。\n添加本地词典 在编辑里选择词典\u0026gt;词典来源\u0026gt;文件，点击添加，我们可以新建一个文件夹来存放我们的字典文件。然后我们将下载好的字典文件解压后，放到这个文件夹中，点击重新扫描就可以识别出本地词典了。\n这样我们就可以在词典中查看已经添加进来的词典了。\n资源 推荐几部精选的词典并附上图片以及下载地址：\n牛津高阶 8 简体 spx （带发音） 百度网盘\n提取码：enp6\nVocabulary.com Dictionary 英文版（联网发音） 百度网盘\n提取码：fsug\n简明英汉必应版（增强版升级） 432万词条 Github\n星际译王 向大家推荐星际译王的词典下载网站，这个网站几乎包含了所有的字典，我们可以选择下载。\n","permalink":"https://hiyoungai.com/posts/ubuntu%E4%B8%8B%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7-goldendict/","summary":"简介 Goldendict 是一款跨平台的翻译软件，支持划词翻译等功能。它更像一种词典或者词典的API工具，通过外挂好本地词典或者网站词典进行翻译，返回的样式就是","title":"Ubuntu下划词翻译工具 GoldenDict"},{"content":"简介 在Linux操作系统下工作久的程序员，在Windows上开发很难适应windows自带的cmd命令行。在此推荐一款开发神器 - Cmder，让你可以在Windows下也可以像Linux中那样使用命令行。\n下载 官网地址\n进入官网以后，有Mini版和完整版，建议完整版，完整版功能更齐全，还可以使用git，下载好解压文件包以后就可以使用。\n解压位置随意，但是个人建议解压到C盘下。如果你解压到了C盘，打开cmder.exe时可能会失败，因为需要使用管理员权限才可以打开。此时我们只需要右键点击Cmder.exe，选择属性 - \u0026gt; 兼容性 - \u0026gt; 勾选以管理员身份运行此程序即可（如下图），这样以后每次打开都不需要使用管理员身份运行了，同时在其他文件夹下使用右键开启也不会报错了。\n配置环境变量 在系统变量PATH添加cmder.exe的路径，使可以在任何位置都可以执行Cmder。\n添加到右键菜单 对开始菜单按钮右击，选择打开windows powershell的管理员模式，执行以下命令即可：\nCmder.exe /REGISTER ALL 执行完该命令后，在任何文件夹下点击鼠标右键就可以执行Cmder了。\n如何从右键菜单删除 我们可以通过修改注册表的方式，删除掉右键菜单中不想要的选项。\n  点击左下角开始菜单 -\u0026gt; 运行（输入regedit）-\u0026gt; 确定或者回车。\n  在打开的注册表中找到：HKEY_CLASSES_ROOT，并点HKEY_CLASSES_ROOT前面的小三角；找到Directory，点击前面的小三角；找到Background，点击前面的小三角；打开shell，可以看到Cmder，看清楚哦，不是cmd是Cmder。右键点击它然后选择删除即可。\n  接下来关闭注册表，在桌面上右击鼠标就能看到Cmder选项被删除啦！\n  界面设置 首先使用windows+alt+p进入界面设置 快捷键 Tab 自动路径补全 Ctrl+T 建立新页签 Ctrl+W 关闭页签 Ctrl+Tab 切换页签 Alt+F4 关闭所有页签 Alt+Shift+1 开启cmd.exe Alt+Shift+2 开启powershell.exe Alt+Shift+3 开启powershell.exe (系统管理员权限) Ctrl+1 快速切换到第1个页签 Ctrl+n 快速切换到第n个页签( n值无上限) Alt + enter 切换到全屏状态 Ctr+r 历史命令搜索 Win+Alt+P 开启工具选项视窗 ","permalink":"https://hiyoungai.com/posts/windows%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7-cmder/","summary":"简介 在Linux操作系统下工作久的程序员，在Windows上开发很难适应windows自带的cmd命令行。在此推荐一款开发神器 - Cmder，","title":"Windows下命令行工具 Cmder"}]