---
title: 论文阅读《Efficient Estimation of Word Representations in Vector Space》
abbrlink: fcba888f
top: false
cover: false
toc: true
mathjax: true
tags:
  - NLP
  - 人工智能
  - 分布式词向量
  - CBOW
  - Skip-gram
categories:
  - 自然语言处理
date: 2019-12-30 17:45:45
excerpt: 论文《Efficient Estimation of Word Representations in Vector Space》阅读笔记。
---

## 前言

这篇论文发表于 2013 年，作者是 Tomas Mikolov，也就是提出 Word2vec（Google 时期）和 Fasttext（Facebook 时期）的大佬。本篇文章主要讲的就是 Word2vec 框架，也就是从这开始，Mikolov 将大家从语言模型时代带入了词嵌入的时代。

论文提出了两种可以从大规模语料库中学习到词向量表示的模型，可以用于计算词相似度的任务。并且相比以往的模型取得了不错的性能和准确度。在 1.6 亿规模的数据集训练只花了一天的时间。



## 介绍

传统的 NLP 系统和技术都将单词作为基本计算单位，词之间没有相关性，只是认为是词库的索引。这样的选择虽然简单，鲁棒性好和可观察，比如语言模型 N-Gram。虽然可以用到大多数任务中，但是还是具有局限性。

随着计算机算力水平的提高，现在可以实现在大数据集进行复杂模型的计算。最成功的可能就是分布式词表示，广泛用于神经网络语言模型等任务，并且性能表现优于 N-Gram 模型。

### 论文目标

本篇论文的目的是可以从数十亿级别的语料库中训练出高质量的词向量，并且词向量之间具有相似度关系，如意思相近的词挨得比较近，而且每个单词可以具有多个相似度。

该论文还发现了单词的向量表示，不仅可以简单的表示相似性，还可以通过词偏移技术进行代数运算：

<center> $\vec{King} - \vec{Man} + \vec{Woman} = \vec{Queen}$</center> </br></br>
## 模型结构

已经有许多种类的模型用来表示连续的词向量，比较出名的有 LSA 和 LDA。而本篇论文着力于使用神经网络模型来学习词向量的表示。实验证明，在保持词向量的线性规律方面，神经网络模型比 LSA 等模型有更好的性能。而且 LDA 在大数据量情况下计算会很吃力。

训练模型的复杂度跟如下公式成正比，试图最大化精度并且最小化训练复杂度。

<center>$O = E \times T \times Q$</center> </br></br>
其中 O 代表训练模型复杂度，E 代表迭代（Epochs）次数，T 代表词汇表中单词数量，Q 表示模型本身结构复杂度（根据参数决定）。通常情况下 E = 3 - 50，T 的值也就是单词数会达到上亿。本文所有模型使用随机梯度下降法和反向传播。

### 前向神经网络语言模型（NNLM）

概率前向神经网络语言模型已经提出了，它包括输入层 Input，投影层 Projection，隐藏层 Hidden 和输出层 Output。输入层中前 N 个词编码为 1-of-V 的向量，V 是词汇表的大小。Input 和 Projection 之间是一个 N$\times$D 的权重矩阵，经过矩阵变换后，在 Projection 中任意时刻只有 N 个输入是激活的。而隐藏层用来计算整个词汇表的概率分布，所以输出层的维度是词汇表的大小 V。如果设隐藏层的节点个数为 H，那么每个训练实例的计算复杂度为：

<center>$Q = N\times D + N\times D\times H + H\times V$</center></br></br>
主要的计算量是在H $\times$ V，但是可以通过层次 Softmax，避免数据归一化或者对词汇表使用二叉树存储等操作减少计算量至 log(v)。这样主要的复杂度就落在了 N$\times$ D$\times$ H的头上。

该论文提出的模型使用的就是层次 Softmax，使用霍夫曼编码树，根据词出现的频率进行建树，实验证明词频对神经网络语言模型有很大影响。使用基于霍夫曼二叉树的层次 Softmax 可以将计算量减少至 log(unigram_perplexity(V))。举个例子来说，如果词汇表有 100 万个单词，那么可以减少两倍的计算量。

### 循环神经网络语言模型（RNNLM）

循环神经网络语言模型已经被提出，以克服前向神经网络语言模型的局限性，例如需要指定上下文长度。RNNs 比浅层神经网络更能表达复杂的模式，它没有投影层 Projection，只有输入层 Input 隐藏层 Hidden和输出层 Output。RNN 的不同之处在于可以保存短暂的记忆或者说是上文的信息可以用于下文中。每个训练实例的计算复杂度为：

<center>$Q = H\times H + H\times V$</center></br></br>
同样的，H $\times$ V 可以通过层次 Softmax 进行优化减少计算量至 log(v)，所以主要计算量在于H $\times$ H。

### 并行训练

为了在大数据集上进行实验，作者在一个分布式框架（DistBelief）上实现了论文中的几个模型。这个框架允许并行运行一个模型的多个副本，每个副本的梯度更新同步通过中央服务器来保持所有参数的一致。对于这种并行训练方式，作者采用mini-batch异步梯度以及自适应的学习速率，整个过程称为Adagrad。采用这种框架，使用100多个模型副本，多个机器的多个CPU核。



## 新的对数线性模型

在本节，作者提出了两个新的模型用于训练分布式词向量。根据前面的介绍，模型训练的主要复杂度是在非线性隐藏层，所以提出的新模型致力于减少或者去掉该部分的计算量。

### 连续词袋模型（CBOW）

第一个模型与 NNML 有些相似，但是去掉了非线性隐藏层，只有输入层，投影层和输出层。区别于 NNML 的投影层，这里的投影层是对所有单词共享的，即所有的单词都投影到同一个位置（所有向量取平均值）。这样不考虑单词的位置顺序信息，叫做词袋模型。同时也会用到将来的词，例如如果窗口 windows 为 2，这样训练中心词的词向量时，会选取中心词附近的 4 个上下文词（前面 2 个后面 2 个）。然后输出层是一个 log-linear 分类器，也就是上面所说的加上了霍夫曼二叉树的 Softmax，所以整体的复杂度是：

<center>$Q = N\times D + D \times log(V)$</center></br></br>
这个模型就称之为 Continuous Bag-of-Words Model 连续词袋模型，它区别于传统的词袋模型是因为使用了上下文的连续词向量表示。模型结构如下（图片中的 windows 为 2）：

![](https://cdn.jsdelivr.net/gh/hiyoung123/CDN/img/img_paper_001_cbow.png)

### 跳词模型（Skip-gram）

第二个模型跟 CBOW 相似，但是它不是像 CBOW 那样根据上下文词学习中心词，而相反的根据中心词去学习上下文中的一个词。更准确地说，使用每个当前单词作为一个具有连续投影层的对数线性分类器的输入，并在当前单词前后的一定范围内（windows）预测单词。通过实验发现，增加 windows 可以提高结果词向量的质量，但同时也增加了计算的复杂性。由于距离较远的单词通常与当前单词的关联性比与当前单词的关联性小，因此我们通过从训练示例中的单词中抽取较少的样本来减少对距离较远的单词的权重。模型整体的复杂度为：

<center>$Q = C \times (D + D \times log(V))$</center></br></br>
其中 C 为 windows 的 2 倍，也是中心词前后上下文词的个数。模型结构为：

![](https://cdn.jsdelivr.net/gh/hiyoung123/CDN/img/img_paper_001_skipgram.png)



## 结果

根据以往的实验和观察，单词之间可以有许多不同类型的相似性，例如 big 和 bigger 类似于 small 和 smaller 具有相同的含义。另一种关系类型的例子可以是单词对 big - biggest 和 small - smallest。令人惊讶的是，这些关系都可以通过词向量之间的线性运算得到正确的结果。就像big-biggest，我们可以通过下面的公式计算：

<center>$\vec{X} = \vec{biggest} - \vec{big} + \vec{small} $</center></br></br>
然后通过余弦距离在向量空间中找到里$\vec{X}$最近的一个词向量，经过良好的训练后，可以正确的找到这个词向量 smallest。

还有的就是，通过加大词向量的维度并且在大数据集上训练的话，可以得到更微妙的语义关系。例如城市和它所属的国家，例如法国对巴黎，德国对柏林。具有这种语义关系的词向量可用于改进现有的许多NLP应用程序，如机器翻译、信息检索和问答系统等。下图是语义-句法词关系测试集中五类语义和九类句法问题的实例：

![](https://cdn.jsdelivr.net/gh/hiyoung123/CDN/img/img_paper_001_relation_table.png)

### 任务描述

为了衡量词向量的质量，作者定义了一个综合测试集，包含五种语义问题和九种句法问题。上图显示了每类中的两个示例。总的来说，有8869个语义问题和10675个句法问题。每个类别中的问题都是通过两个步骤创建的：首先，手动创建类似单词对的列表。然后，通过连接两个词对形成一个大的问题列表。例如，列出了68个美国大城市及其所属的州，并通过随机选择两个词对，形成了大约 2.5k 的问题。测试集中只包含单个标记词，因此不存在多词实体（such as New York）。

评价模型结果好坏的标准就是上述的词向量线性运算，如果通过线性运算得到的单词与正确的单词是完全一致的，那么就代表该词向量是正确的。所以同义词很难被计算出来，因为没有对同义词的输入，所以模型不可能达到 100% 的准确率。但是该模型的准确率与某些任务是正相关的，所以还是有一些用处的。

### 精度最大化

论文使用了谷歌新闻语料库来训练词汇向量，这个语料库包含大约 6B 个 token，并且将词汇量限制在一百万个最常见的词。为了能够快速的评估模型结构体系和参数的最佳结果，作者首先在数据集的子集上进行评估，词汇限制在最频繁的 30K 单词。下图是使用 CBOW 在不同向量维度和不同数据量下的结果：

![](https://cdn.jsdelivr.net/gh/hiyoung123/CDN/img/img_paper_001_result_cbow_01.png)

可以看出达到某个点之后，增大向量维度并没有增加精度反而减少。而增加数据量也只是微小的增加精度，但是根据之前所说的训练复杂度公式可知，当增大单词数量时，训练复杂度也在增加。

### 模型比较

作者也做了和传统模型的比较工作，使用相同的数据集，相同 640 维度的词向量，也不仅限使用 30k 的单词，并且使用了全部的测试集数据。以下是训练结果的比较：

![使用在相同数据上训练的模型与640维字向量对模型进行比较。本文语义-句法关系测试集和[20]的句法关系测试集报告精确度。](https://cdn.jsdelivr.net/gh/hiyoung123/CDN/img/img_paper_001_result_002.png)

![比较语义句法词汇关系测试集上的公共可用词汇向量和我们模型中的词汇向量。使用完整词汇表。](https://cdn.jsdelivr.net/gh/hiyoung123/CDN/img/img_paper_001_result_003.png)

![在相同数据上三个epoch训练的模型与为一个epoch训练的模型的比较,使用完整的语义-句法数据集。](https://cdn.jsdelivr.net/gh/hiyoung123/CDN/img/img_paper_001_result_004.png)

### 大规模并行训练模型

在 DistBelief 上使用谷歌 News 6B 数据集训练的几个模型的结果对比：

![使用DistBelief分布式框架训练的模型的比较，请注意使用1000维向量训练NNLM将花费很长时间才能完成。](https://cdn.jsdelivr.net/gh/hiyoung123/CDN/img/img_paper_001_result_005.png)

### Microsoft Research Sentence Completion Challenge

微软的句子完成挑战最近被作为一项推进语言建模和其他NLP技术的任务引入，这个任务由1040个句子组成，每个句子中有一个单词丢失，目标从五个合理的选择列表中选择与句子其余部分最连贯的单词。本论文的模型与传统模型在该比赛中的分数对比：

![Microsoft Sentence完成挑战中模型的比较和组合。](https://cdn.jsdelivr.net/gh/hiyoung123/CDN/img/img_paper_001_result_006.png)



## 总结

词向量已经成为现在 NLP 深度学习中不可缺少的一部分，从 Word2vec 到 Bert 都是促进 NLP 得到飞跃式提升的重要技术。训练出质量高覆盖率广的词向量，可以有效的提高下游任务的性能准确率，如机器翻译，情感分类等。而词向量训练的难点主要就是词汇表和语料库的规模，目前 Bert 使用的语料量级已经很难超越，不知道这是不是词向量的顶点？



## References

测试集：http://www.fit.vutbr.cz/~imikolov/rnnlm/word-test.v1.txt
官方源码：https://code.google.com/archive/p/word2vec/

